<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-06T05:27:59.976Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>softmountain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（图论初学）单源最短路径：dijkstra</title>
    <link href="http://yoursite.com/2020/04/04/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra/"/>
    <id>http://yoursite.com/2020/04/04/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra/</id>
    <published>2020-04-04T03:21:41.637Z</published>
    <updated>2020-04-06T05:27:59.976Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p><a id="more"></a><ol><li>初始化d[1]=0,然后将其余的dist全部设置为最大</li><li>进行n-1次循环，每次都找最小了dist[x],将x标记</li><li>扫描该x的全部出边（x,y,z）,ifd[y]>d[x]+z),更新d[y] </li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><algorithm></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><string></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><cstdlib></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><cstring></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<m;i++){</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j<=m;j++){</span><br><span class="line"><span class="keyword">if</span>(!v[j]&&(x==<span class="number">0</span>||d[j]<d[x]))x=j;</span><br><span class="line">}</span><br><span class="line">v[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j<=m;j++){</span><br><span class="line">d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">cin</span>>>m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=m;i++){</span><br><span class="line">a[i][i]=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i<=m;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j<i;j++){</span><br><span class="line"><span class="built_in">cin</span>>>s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"x"</span>){</span><br><span class="line">a[i][j]=a[j][i]=INF;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k<s.<span class="built_in">size</span>();k++){</span><br><span class="line">n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">}</span><br><span class="line">a[i][j]=a[j][i]=n;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i<=m;i++){</span><br><span class="line">d[i]=INF;</span><br><span class="line">}</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">search();</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i<=m;i++){</span><br><span class="line">ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">cout</span><<ans<<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度O(n^2)…适用于求单源路径…<br>最优序列方法，之后更新…</p><p>categrories: </p><ul><li>ACM</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
