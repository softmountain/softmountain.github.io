<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF每日一题 四月</title>
    <url>/2020/04/17/CF%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%9B%9B%E6%9C%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces edu round 85 A-D</title>
    <url>/2020/04/11/codeforces-edu-round-85-A-D/</url>
    <content><![CDATA[<p>昨晚的比赛并没有参加，但是今天早上参考大佬的代码，花时间把前面相对简单的四题给补了</p>
<a id="more"></a>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/contest/1334" target="_blank" rel="noopener">https://codeforces.com/contest/1334</a></p>
<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p>意思是进行一场游戏，会显示游戏次数和成功次数，由题意可知，游戏次数必定大于成功次数，然后问显示的数据是真是假，用几个条件判断一下就好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">1</span>,m1=<span class="number">0</span>,m2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(m1&gt;a[i]||m2&gt;b[i]||a[i]&lt;b[i]||b[i]-m2&gt;a[i]-m1)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m1=a[i],m2=b[i];	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p>题意：从一个序列里面随机抽取几个元素，使得这几个元素元素的平均数大于或等于目标值，问最多能抽取几个元素</p>
<p>首先排序(最大的在前面)，然后sum从左往右遍历，求和，如果一直满足条件ans++;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,a[N],_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="comment">//这里使用scanf()函数对_进行赋值，然后直接_--，太骚了 </span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		reverse(a,a+n);			</span><br><span class="line">		<span class="comment">//大佬的代码简洁，不写cmd，直接reverse满足 </span></span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		ll s=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			s+=a[i];</span><br><span class="line">			<span class="keyword">if</span> (s&gt;=(ll)(i+<span class="number">1</span>)*x) ans=i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>题意：有一群怪物将作者围在中间，每个怪物分别拥有生命值和爆炸值两个数值，怪物死亡时会爆炸，对下一个怪物造成自己爆炸值数值的伤害(如果是最后一个，那么就是第一个，因为围成了圈)，求最低造成多少伤害，就能够将所有的怪物清除。</p>
<p>分析：对下一个怪物的伤害不会超过下一个怪物的生命值，所以杀死一个怪物的代价应该是</p>
<p>penalty=min(0,a[i]-b[i+n-1%n])    (前面的一个怪物已经被引爆的情况)</p>
<p>原本我是想用优先队列来写的，计算一个怪物的生命值和爆炸最多能对下一个怪物造成的伤害之和为序不停从堆中抽取，后来发现实际上怪物的生命值是动态的，不能用静态的生命值来算，只能作罢。看了别人的代码，才恍然大悟，这是一道贪心题，但是计算的应该是消灭一个怪物所要付出的代价而不是所能造成的最大化伤害。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">ll extra[N],a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,a+i,b+i);</span><br><span class="line">		ll s=<span class="number">0</span>,d=<span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			extra[i]=<span class="built_in">max</span>(<span class="number">0l</span>l,a[i]-b[(i+n<span class="number">-1</span>)%n]);</span><br><span class="line"> <span class="comment">//这里计算在总生命值量和总爆炸伤害量已知的情况下，杀死一个怪物的代价</span></span><br><span class="line">			s+=extra[i];</span><br><span class="line">		<span class="comment">//	printf("%d %lld\n",i,extra[i]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) d=<span class="built_in">min</span>(d,s-extra[i]+a[i]);</span><br><span class="line"><span class="comment">//找到杀死一头怪物所要付出的最小代价</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思：刚开始我想岔是因为没有考虑到整体，而是盲目的从局部性价比最优的方式来计算，实际上从整体生命值和总体爆炸伤害值来看，如果我们选择不同的突破口，那么有一部分代价是完全逃避不了的，因为你如果不动它，那么上一个怪物的伤害值是无论如何都不可能杀死他的，我们只能做到第一步就找到代价最小的方式来减少损失</p>
<h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：有n个点，从1到 n ,再从 n 到1，任意两点之间都存在两条有向边，要求找到从1到n再回到n,经过且不重复经过每一条边，最小的字典序方案，给出字典序方案中从 l 位到 r 位的序列号</p>
<p>这道题为贪心和图论的结合，想到解决方法并不难，但是想要用代码实现感觉让人头大,感觉没有特定的板子啊，这是我看到的解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&gt;s[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> a=lower_bound(s+<span class="number">1</span>,s+n,x)-s;</span><br><span class="line">	<span class="keyword">int</span> b=x-s[a<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span> (b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b/<span class="number">2</span>+a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%lld%lld"</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">		rep(i,<span class="number">1</span>,n+<span class="number">1</span>) s[i]=s[i<span class="number">-1</span>]+<span class="number">2</span>*(n-i);</span><br><span class="line">		<span class="keyword">for</span> (ll i=l;i&lt;=r;i++)</span><br><span class="line">		 	<span class="built_in">printf</span>(<span class="string">"%d "</span>,calc(i));</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);<span class="comment">//换行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 632 Div.2回顾</title>
    <url>/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ</p>
<a id="more"></a>

<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p> <a href="https://codeforces.com/contest/1333" target="_blank" rel="noopener">https://codeforces.com/contest/1333</a></p>
<h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><p>一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'W'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'B'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><p>给定上下两个序列，上面一个序列可以进行一种运算:</p>
<p>对任意i &lt; j ,可以使得aj = ai+aj </p>
<p>要求是能否通过这种运算使得上面的数列等于下面的，其实就是找上面数列的1和-1的位置，再和每一位进行比对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod9 998244353</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,m,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vis[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">                <span class="keyword">if</span>(b[i]&gt;a[i]&amp;&amp;vis[<span class="number">0</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[i]&lt;a[i]&amp;&amp;vis[<span class="number">1</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">1</span>) vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">-1</span>) vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><p>题意给定一个序列，只能从左端或者右端截取一段走形成新的子序列，不存在可以从中间直接拿取（我就理解错了），所以这样子算来实际的序列数量是1+2+…..n，即 (n+1)*n/2 ,只要子序列中任意一个存在和为零的情况，那么这个序列就不符合要求，结果求得是符合要求的序列的数量，刚开始我还以为是一个求子序列和的问题，没有特别多的思路就选择做了后面的题目，毕竟2^n难以处理，结果因为传达了错误的题意还坑了和自己的一起写的大佬（捂脸）</p>
<p>处理：由于其子序列取得方式，我们可以推理，假设一个序列和为零，那么其右端所有序列（即母序列）也不符合要求，进一步想，我们会发现，假设从左往右计数求和sum，如果sum的值出现了两次，那么说明中间一段必定为和为零的序列，所以可以使用map<int int >记录下每个sum出现的最新位置，如果出现了重复的sum,就对其右边的母序列进行清除。不用注意重复子序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>,n,sum=<span class="number">0</span>,cnt=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成1，避免首元素就是0的情况</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.count(sum))&#123;</span><br><span class="line">        	cnt=<span class="built_in">max</span>(cnt,mp[sum]);</span><br><span class="line">		&#125;</span><br><span class="line">        ans+=i-cnt;</span><br><span class="line">        mp[sum]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成i+1,剪掉0子序列的首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h2><p>将序列当中全部向左转的跳到左边，右转的调到右边，这里看到了一位学长的代码，非常熟练地使用了各种STL，我从中学到了很多新的东西，比如范围for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;type&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:k)	<span class="built_in">cout</span>&lt;&lt;n;</span><br></pre></td></tr></table></figure>

<p>题解如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,k,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        p.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'R'</span>&amp;&amp;a[i+<span class="number">1</span>]==<span class="string">'L'</span>) </span><br><span class="line">                p.push_back(i++),swap(a[i],a[i<span class="number">-1</span>]),</span><br><span class="line">            	flag=<span class="literal">false</span>,sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        q.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k||sum&lt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d:q)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,d.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:d) <span class="built_in">printf</span>(<span class="string">" %d"</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>同余</title>
    <url>/2020/04/13/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<p>最近一次的周赛中暴露了同余逆元的短板，连板子都不会用，哎，只能加紧补了</p>
<a id="more"></a>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果a,b对正整数n的余数相等，那么a≡b(mod n)</p>
<h3 id="同余类和剩余类"><a href="#同余类和剩余类" class="headerlink" title="同余类和剩余类"></a>同余类和剩余类</h3><p>对于所有a∈ [0,m-1], 集合 {a+km}对于m同余，该集合称为一个m的同类余，一个模m的同类余一共有{0,1,…..m-1}共m个，被称为完全剩余系</p>
<p>完全剩余系中与m互质的同类余有φ(m)个，被称为m的简化剩余系，简化剩余系的积也是m的简化剩余系</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若p是质数，则对于任意正整数a，有a^p≡a(mod p)</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若正整数 a,n互质，那么a^φ(n)≡1(mod n),其中φ(n)是欧拉函数(不超过n的简化剩余系元素)</p>
<p>推论：</p>
<p>若正整数a ,n互质,对于任意正整数b，</p>
<p>有:  a^b≡a^(b mod φ(n)) (mod n)</p>
<p>这些定理的证明链接：<a href="https://www.cnblogs.com/zylAK/p/9569668.html" target="_blank" rel="noopener">https://www.cnblogs.com/zylAK/p/9569668.html</a></p>
<p>快速幂取余的板子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mod</span><span class="params">(LL a,LL b,LL mod)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="comment">//b==1</span></span><br><span class="line">            ans=ans*a%mod；</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别情况：当a，n不一定互质的且b&gt;φ(n)情况下，可以有：</p>
<p>a^b≡a^(b modφ(n)+φ(n)) (mod n)</p>
<p>例题：<a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">POJ3696</a></p>
<p>最近发现欧拉定理的拓展不能用在快速幂板子，会导致答案错误，是一把双刃剑</p>
<h3 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h3><p>某打不出名字的定理：</p>
<p>对于任意整数a,b,存在一对整数x,y,满足 ax+by == gcd(a,b)</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123; x=<span class="number">1</span>,y=<span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> z=x; x=y; y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>若整数 b,m互质，并且 b|a，则存在一个整数x，使得a/b≡a*x(mod m),则x称为b的模m乘法逆元，记为b ^-1(mod m)</p>
<p>当模数m为质数时，b^m-2即为b的乘法逆元</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 633 div.2&amp;&amp; round 634 div.3回顾</title>
    <url>/2020/04/15/codeforces-round-633-div-2-round-634-div-3%20round%20635%20div.2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>codeforces上的比赛一直都很多，索性一次性将有价值的题目全部都放到一起来写了</p>
<a id="more"></a>

<h2 id="round-633"><a href="#round-633" class="headerlink" title="round 633"></a>round 633</h2><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：给定指定的n个点，n-1条无向路（也就是说没有成环的可能），可以给路径随机分配正权值，从一个叶节点走到另外的叶节点路途中，所途径权值异或之和应该为零，问权值数量最少为多少，最多为多少</p>
<p>分析：首先我们先判断最小值的情况，我们可以发现，如果存在有两个节点之间的边数为奇数，那么权值的种类最小数必定为三，然后再去判断最大值的情况，两个或者两个以上叶节点同时连在了一个点上的情况中，这几个叶结点的权值边应该全部相同，所以只需要保留一个就可以了，把删掉的节点数用一个数字存起来，最大值就是 n-1-该数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,ans=<span class="number">0</span>,fl=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100005</span>],one;</span><br><span class="line"><span class="keyword">int</span> qi=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">-1</span>&amp;&amp;v[x].<span class="built_in">size</span>()==<span class="number">1</span>)&#123;	<span class="comment">//从所有的叶节点出发，到其他的的叶节点，判断路径的奇偶</span></span><br><span class="line">        <span class="keyword">if</span>(z%<span class="number">2</span>) ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,v[x].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x][i]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v[x][i],x,z+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> minn=<span class="number">0</span>,maxn=n<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        v[a].push_back(b);</span><br><span class="line">        v[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i].<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;qi==<span class="number">0</span>)&#123;</span><br><span class="line">            qi=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,v[i].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;			<span class="comment">//删除多余叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(v[v[i][j]].<span class="built_in">size</span>()==<span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>) fl+=cnt<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(qi,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>) minn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minn=<span class="number">3</span>;</span><br><span class="line">    maxn-=fl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minn,maxn);</span><br></pre></td></tr></table></figure>

<h2 id="round-634"><a href="#round-634" class="headerlink" title="round 634"></a>round 634</h2><h3 id="E1题"><a href="#E1题" class="headerlink" title="E1题"></a>E1题</h3><p>题意：给定一个数组，问在不改变顺序的情况下，通过删减数组中元素，使得数组变成’ABA’型回文串是否可能，如果可能，请输出最大的回文串的长度</p>
<p>分析：dp题，用数组从左往右遍历，用a[i] [j]表示当前位置 j 情况下字符 i 的数量，然后再用从每一个位置开始，</p>
<p>以当前位置为左端，设置右端，再遍历26个字母的存在，使得</p>
<p>maxin=max(maxin,a[i] [r+1]-a[i] [l]);</p>
<p>maxout=max(maxout,min(a[i] [l],a[i] [n]-a[i] [r+1])*2);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) int((a).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; int(n); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fore(i, l, r) for (int i = int(l); i &lt; int(r); ++i)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : a) <span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">		forn(i, n) &#123;</span><br><span class="line">			forn(j, <span class="number">26</span>) cnt[j][i + <span class="number">1</span>] = cnt[j][i];</span><br><span class="line">			++cnt[a[i] - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		forn(i, <span class="number">26</span>) ans = <span class="built_in">max</span>(ans, cnt[i][n - <span class="number">1</span>]);</span><br><span class="line">		forn(l, n) fore(r, l, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> cntin = <span class="number">0</span>, cntout = <span class="number">0</span>;</span><br><span class="line">			forn(el, <span class="number">26</span>) &#123;</span><br><span class="line">				cntin = <span class="built_in">max</span>(cntin, cnt[el][r + <span class="number">1</span>] - cnt[el][l]);</span><br><span class="line">				cntout = <span class="built_in">max</span>(cntout, <span class="built_in">min</span>(cnt[el][l], cnt[el][n] - cnt[el][r + <span class="number">1</span>]) * <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cntin + cntout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈问题：寻找最大矩形面积</title>
    <url>/2020/04/12/%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p> 题意：求若干个相邻矩形并集内部所能找到的最大矩形面积</p>
<a id="more"></a>

<p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ2559</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[n+<span class="number">1</span>]=p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;s[p])</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">width</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[p]&gt;a[i])&#123;		</span><br><span class="line">			<span class="built_in">width</span>+=w[p];</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">width</span>*s[p]);</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="built_in">width</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构 KMP模式匹配</title>
    <url>/2020/04/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>KMP匹配是判断两个线性表之间是否存在子母串关系的算法，并且能够定位到子串所处的位置</p>
<a id="more"></a>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1 .首先对小的字符串A进行自我”匹配”，设置next数组，其中next[i]表示“A中以a[i]结尾的非前缀子串”与”A的前缀”所能匹配到的最大长度</p>
<p>公式： next[i]=max{j},其中j&lt;i并且A[i-j+1 ~ i]==A[1 ~ j]</p>
<p>特别的：当不存在这样的 j 时，令next[i]=0</p>
<p>2 .对字符串A和B进行匹配，求出一个数组f，其中f[i]表示“B中以i结尾的字串”与”A的前缀”能够匹配到的最大长度</p>
<p>公式： f[i]=max{j},其中j&lt;i并且B[i-j+1 ~i]==A[1 ~ j]</p>
<p>当j的长度超过了n时，应该把j=next[j];</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于j&lt;i,则j是next[i]的一个候选项，则小于j的next[i]的最大候选项是next[j],这是一个套娃的关系，直到满足条件或者next[j]==0</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next数组的求法</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>]) j=next[j];</span><br><span class="line">    <span class="comment">//找到符合条件的j,或者j==0;</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]==a[j+<span class="number">1</span>]) j++; </span><br><span class="line">    <span class="comment">//如果符合条件，加上末尾的元素</span></span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f数组的求法（大同小异）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(j==n||b[i]!=a[j+<span class="number">1</span>])) j=next[j];</span><br><span class="line">    <span class="keyword">if</span>(b[i]==a[j+<span class="number">1</span>]) j++;</span><br><span class="line">	f[i]=j;</span><br><span class="line">    <span class="comment">//当f[i]==n的时候，说明子串就出现了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ1961</a></p>
<p>题意：求循环元，首先我们设s[1~i]拥有长度为len的循环元</p>
<p>那么len必定满足以下条件：</p>
<p>len|i &amp;&amp; s[len+1<del>i]==s[1</del>i-len]</p>
<p>而最小循环节则满足</p>
<p>s[len] (最小循环节)=next[i]</p>
<p>综上，得到代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[j+<span class="number">1</span>]!=a[i]) j=next[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i]) j++;</span><br><span class="line">        next[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">        calc_next();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test case"</span>&lt;&lt;++T&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>&amp;&amp;i/(i-next[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;i/(i-next[i])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何储存路径元素</title>
    <url>/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="最短路路径"><a href="#最短路路径" class="headerlink" title="最短路路径"></a>最短路路径</h1><p>题目链接：<a href="http://poj.org/problem?id=1734" target="_blank" rel="noopener">POJ1734</a></p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图使用floyd，最小环长度应该是：</p>
<p>min( 1&lt;= i&lt; j &lt; k) {d[i,j] + a[i,k] + a[k,j]}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],d[N][N],pos[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    get_path(x,pos[x][y]);</span><br><span class="line">    path,push_back(pos[x][y]);</span><br><span class="line">    get_path(pos[x][y],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[y][x]=a[x][y]=<span class="built_in">min</span>(a[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(d,a,<span class="keyword">sizeof</span> a);	<span class="comment">//这波很骚；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;ik&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ki++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]+a[i][k]+a[k][j]&lt;ans)&#123;</span><br><span class="line">                    ans=d[i][j]+a[i][k]+a[k][j];</span><br><span class="line">                    path.<span class="built_in">clear</span>();</span><br><span class="line">                    path.push_back(i);</span><br><span class="line">                    get_path(i,j);</span><br><span class="line">                    path.push_back(j);</span><br><span class="line">                    path.push_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]&gt;d[i][k]+d[k][j])&#123;</span><br><span class="line">                    d[i][j]=d[i][k]+d[k][j];</span><br><span class="line">                    pos[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了pos[i] [j]这个矩阵存储了两个点之间的中间路径，同时get_back函数通过递归调用再次得出i与k,k与j之间的关系，但是注意，这个方法只能存储最短路的路径，不能存储所有的路径。。。</p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图使用二分堆优化的dijkstra,同样是使用pos存储中间节点，方法：枚举1-n之间的起点s,从s开始出堆，但是s出堆之后立刻将d[s]设置为无穷大，这样子s第二次入堆时得到的就是最小有向环</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）两点间无向最短路径 floyd</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/</url>
    <content><![CDATA[<p>floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化</p>
<p>如果想要了解内部缘由不妨移步：<a href="https://www.zhihu.com/question/30955032/answer/68834307" target="_blank" rel="noopener">为什么k要放在最外层</a></p>
<a id="more"></a>

<p>设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。</p>
<p>得到公式：</p>
<p>D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j])</p>
<p>可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;				<span class="comment">//floyd的状态转移方程：d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]),可以转换成三重循环的。。 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		<span class="comment">//最外层循环是为了找到能不能有其他点帮助目标点完成最短路。。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                d[a[i]][a[j]]=d[a[j]][a[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum+=d[i][j];</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans*<span class="number">100</span>/(n<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递闭包：传递推导尽量多的元素之间的关系(感觉并查集也能解决相等的关系，但是大于小于不行)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]|=d[i][k]&amp;d[k][j];</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）单源最短路径-dijkstra</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/</url>
    <content><![CDATA[<p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p>
<a id="more"></a>

<ol>
<li>初始化d[1]=0,然后将其余的 distance 全部设置为最大</li>
<li>进行n-1次循环，每次都找最小了distance[x],将x标记</li>
<li>扫描该x的全部出边（x,y,z）,if d[y]&gt;d[x]+z),更新d[y] </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[j]&amp;&amp;(x==<span class="number">0</span>||d[j]&lt;d[x]))	x=j;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		a[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="string">"x"</span>)&#123;</span><br><span class="line">				a[i][j]=a[j][i]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">					n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a[i][j]=a[j][i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		d[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	search();</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，主要复杂度来自第一步对全局最小值的寻找，适用于求单源路径.</p>
<p>下面是使用二叉树堆对dist进行维护之后，可以在O(mlogn)的时间内实现dijkstra:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],next[M],d[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//注意这里的key值是dist值的相反数，因为要选取最小值，第二个值为对应的节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.top().second,q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],z=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）bellman-ford和SPFA</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/</url>
    <content><![CDATA[<p>bellman-ford流程：</p>
<ol>
<li>扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y]</li>
</ol>
<p>重复以上步骤，直到没有更新步骤发生</p>
<p>复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra</p>
<a id="more"></a>

<p>SPFA:</p>
<ol>
<li><p>建立一个队列，最初队列中只有起点1</p>
</li>
<li><p>取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队</p>
</li>
<li><p>重复上面步骤，直到队列为空</p>
</li>
</ol>
<p>这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>(<span class="keyword">int</span>) q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>,v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],x=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!v[x])	q.push(y),v[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SPFA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是该方法对于边权存在为负数的边同样适用。</p>
<p>并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）邻接矩阵和邻接表</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<p>对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。</p>
<a id="more"></a>

<ol>
<li><p>邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。</p>
</li>
<li><p>邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。</p>
<p>插入和遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入有向边(x,y,z)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">    <span class="comment">//注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有x出发的有向边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;	</span><br><span class="line">    <span class="comment">//这里面的i如果为0.结束循环</span></span><br><span class="line">	<span class="keyword">int</span> y=ver[i],x=ver[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
</search>
