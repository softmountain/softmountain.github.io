<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>codeforces edu round 85 A-D</title>
    <url>/2020/04/11/codeforces-edu-round-85-A-D/</url>
    <content><![CDATA[<p>昨晚的比赛并没有参加，但是今天早上参考大佬的代码，花时间把前面相对简单的四题给补了</p>
<a id="more"></a>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/contest/1334" target="_blank" rel="noopener">https://codeforces.com/contest/1334</a></p>
<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p>意思是进行一场游戏，会显示游戏次数和成功次数，由题意可知，游戏次数必定大于成功次数，然后问显示的数据是真是假，用几个条件判断一下就好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">1</span>,m1=<span class="number">0</span>,m2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(m1&gt;a[i]||m2&gt;b[i]||a[i]&lt;b[i]||b[i]-m2&gt;a[i]-m1)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m1=a[i],m2=b[i];	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p>题意：从一个序列里面随机抽取几个元素，使得这几个元素元素的平均数大于或等于目标值，问最多能抽取几个元素</p>
<p>首先排序(最大的在前面)，然后sum从左往右遍历，求和，如果一直满足条件ans++;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,a[N],_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="comment">//这里使用scanf()函数对_进行赋值，然后直接_--，太骚了 </span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		reverse(a,a+n);			</span><br><span class="line">		<span class="comment">//大佬的代码简洁，不写cmd，直接reverse满足 </span></span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		ll s=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			s+=a[i];</span><br><span class="line">			<span class="keyword">if</span> (s&gt;=(ll)(i+<span class="number">1</span>)*x) ans=i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>题意：有一群怪物将作者围在中间，每个怪物分别拥有生命值和爆炸值两个数值，怪物死亡时会爆炸，对下一个怪物造成自己爆炸值数值的伤害(如果是最后一个，那么就是第一个，因为围成了圈)，求最低造成多少伤害，就能够将所有的怪物清除。</p>
<p>分析：对下一个怪物的伤害不会超过下一个怪物的生命值，所以杀死一个怪物的代价应该是</p>
<p>penalty=min(0,a[i]-b[i+n-1%n])    (前面的一个怪物已经被引爆的情况)</p>
<p>原本我是想用优先队列来写的，计算一个怪物的生命值和爆炸最多能对下一个怪物造成的伤害之和为序不停从堆中抽取，后来发现实际上怪物的生命值是动态的，不能用静态的生命值来算，只能作罢。看了别人的代码，才恍然大悟，这是一道贪心题，但是计算的应该是消灭一个怪物所要付出的代价而不是所能造成的最大化伤害。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">ll extra[N],a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,a+i,b+i);</span><br><span class="line">		ll s=<span class="number">0</span>,d=<span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			extra[i]=<span class="built_in">max</span>(<span class="number">0l</span>l,a[i]-b[(i+n<span class="number">-1</span>)%n]);</span><br><span class="line"> <span class="comment">//这里计算在总生命值量和总爆炸伤害量已知的情况下，杀死一个怪物的代价</span></span><br><span class="line">			s+=extra[i];</span><br><span class="line">		<span class="comment">//	printf("%d %lld\n",i,extra[i]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) d=<span class="built_in">min</span>(d,s-extra[i]+a[i]);</span><br><span class="line"><span class="comment">//找到杀死一头怪物所要付出的最小代价</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思：刚开始我想岔是因为没有考虑到整体，而是盲目的从局部性价比最优的方式来计算，实际上从整体生命值和总体爆炸伤害值来看，如果我们选择不同的突破口，那么有一部分代价是完全逃避不了的，因为你如果不动它，那么上一个怪物的伤害值是无论如何都不可能杀死他的，我们只能做到第一步就找到代价最小的方式来减少损失</p>
<h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：有n个点，从1到 n ,再从 n 到1，任意两点之间都存在两条有向边，要求找到从1到n再回到n,经过且不重复经过每一条边，最小的字典序方案，给出字典序方案中从 l 位到 r 位的序列号</p>
<p>这道题为贪心和图论的结合，想到解决方法并不难，但是想要用代码实现感觉让人头大,感觉没有特定的板子啊，这是我看到的解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&gt;s[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> a=lower_bound(s+<span class="number">1</span>,s+n,x)-s;</span><br><span class="line">	<span class="keyword">int</span> b=x-s[a<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span> (b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b/<span class="number">2</span>+a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%lld%lld"</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">		rep(i,<span class="number">1</span>,n+<span class="number">1</span>) s[i]=s[i<span class="number">-1</span>]+<span class="number">2</span>*(n-i);</span><br><span class="line">		<span class="keyword">for</span> (ll i=l;i&lt;=r;i++)</span><br><span class="line">		 	<span class="built_in">printf</span>(<span class="string">"%d "</span>,calc(i));</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);<span class="comment">//换行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing 记录 第一章</title>
    <url>/2020/04/20/acwing-%E8%AE%B0%E5%BD%95%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>这里是acwing上面dp专题的价值题的收集，算是dp专题吧</p>
<a id="more"></a>

<h2 id="275-传纸条"><a href="#275-传纸条" class="headerlink" title="275.传纸条"></a>275.传纸条</h2><h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/solution/acwing/content/2851/" target="_blank" rel="noopener">https://www.acwing.com/solution/acwing/content/2851/</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题是一道线性dp，求出不重合的两条路线的权值之和，我们可以设想为两个人在互不重合的路线上同时出发同时到达，设他们所处的坐标横纵之和为m+n，第一位的横坐标为i,第二位为j,对应的纵坐标就是m+n-i,m+n-j，由此我们可以确定状态f[k] [i] [j]，即坐标值和为k的时候两个人的权值之和的最大值，那么能够走到这一步有四种可能，分别为右右，右下，下右，下下，并且我们注意到，如果i==j,那么说明此时两个人的走到了同一位置，此时由于此种情况不可能存在，我们之间舍去即可</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>暴力枚举加部分贪心，通过枚举左端的人的位置，由于右端的人不可能再从更左的地方出发（可能出发的情况早已经储存在了之前的状态之中），那么我们可得到四重循环的结果f[n-1] [m] [n-1] [m]，这样子有一个好处，可以避免对两人坐标相同时的讨论，但是复杂度仍然很高，无论是空间还是时间都是O(n^4)</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">55</span>][<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">// (i,j) 是第一条路径坐标 (k,l) 是第二条</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=j+<span class="number">1</span>;l&lt;=m;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> w1=f[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],w2=f[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l];</span><br><span class="line">                    <span class="keyword">int</span> w3=f[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],w4=f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l];</span><br><span class="line">                    f[i][j][k][l]=<span class="built_in">max</span>(w1,<span class="built_in">max</span>(w2,<span class="built_in">max</span>(w3,w4)))+v[i][j]+v[k][l];</span><br><span class="line">                    <span class="comment">//我们用贪心思想可得两条路径肯定不相交 (能取数就取数)</span></span><br><span class="line">                    <span class="comment">//那么令 l=(j+1,m) 即满足了此条件 (保证了第二条路线一定在第一条路线下面) </span></span><br><span class="line">                    <span class="comment">//不用判重因为不会重两条路径不相交 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][m<span class="number">-1</span>][n<span class="number">-1</span>][m]); </span><br><span class="line">    <span class="comment">//dp 是达不到 (n,m) 的,但 (n,m) 等价于 (n-1,m),(n,m-1) (因为 v(n,m)==0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>就是设定总计的步数为k,两人坐标分别为(i,k-i) (j,k-j)</p>
<p>从而得到状态f[k] [i] [j]</p>
<p>当i != j时，此时两者处在不同的位置，那么就可以通过四种达到该状态的方式来得出f[k] [i] [j]的值，如果i==j，直接不做讨论，跳过完事，除非时i==j==0||n的情况</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N * <span class="number">2</span>][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n + m; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, k - m); i &lt;<span class="built_in">min</span>(n+<span class="number">1</span>,k); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>, k - m); j &lt;<span class="built_in">min</span>(n+<span class="number">1</span>,k); j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = g[i][k - i];</span><br><span class="line">                        <span class="keyword">if</span> (i != j || k == <span class="number">2</span> || k == n + m)</span><br><span class="line">                        &#123;</span><br><span class="line">                            t += g[j][k - j];</span><br><span class="line">                            f[k][i][j] = <span class="built_in">max</span>(f[k][i][j], f[k - <span class="number">1</span>][i - a][j - b] + t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n + m][n][n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法一规避了对两者位置相同的时的判断，代码简化且方式粗暴，但是由于没有对步长的限制，导致了对时间和空间上的极大浪费，第二种方式通过对步长的限制，使得计算降低了一个维度</p>
<h2 id="1014-登山"><a href="#1014-登山" class="headerlink" title="1014.登山"></a>1014.登山</h2><h3 id="链接：-1"><a href="#链接：-1" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1016/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/1016/</a></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这是一道经典的LIS题目，但是我们可以用双dp数组的思想来做，降低代码复杂度</p>
<p>方法：设置两个数组dp_high,dp_sum，前者dp_high[i]表示序列为i的元素结尾的序列的最长上升子序列长度，后者dp_sum[i]表示以i结尾的序列的最长先上升在下降序列长度</p>
<p>有状态转移方程：对任意j&lt;i</p>
<p>if(a[j]&lt;a[i]) dp_high[i]=max(dp_high[i],dp_high[j]+1)</p>
<p>else if(a[j]&gt;a[i]) </p>
<p>dp_sum[i]=max(dp_sum[i],max(dp_sum[j]+1,dp_high[j]+1))</p>
<p>时间复杂度没有明显降低，但是提供了一种嵌套迭代的思想</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line"></span><br><span class="line">    dp_inc[i] = <span class="number">1</span>, dp_dec[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[j] &lt; h[i])</span><br><span class="line">            dp_inc[i] = <span class="built_in">max</span>(dp_inc[i], dp_inc[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(h[j] &gt; h[i])</span><br><span class="line">            dp_dec[i] = <span class="built_in">max</span>(dp_dec[i], <span class="built_in">max</span>(dp_inc[j]+<span class="number">1</span>, dp_dec[j]+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(dp_inc[i], dp_dec[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1011-登山"><a href="#1011-登山" class="headerlink" title="1011.登山"></a>1011.登山</h2><h3 id="链接：-2"><a href="#链接：-2" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/problem/content/1012/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/1012/</a></p>
<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>求最大上升子序列和最长不降子序列的长度，可以使用lower_bound和upper_bound两个函数，两者正常情况下的都是对升序列使用，如果需对降序列使用必须使用greater<type>()或者重载模型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对降序序列使用</span><br><span class="line">    lower_bound(f,f+n,a,greater&lt;<span class="keyword">int</span>&gt;())求出第一个小于或等于a的f[n]的位置，没有返回<span class="built_in">end</span>;</span><br><span class="line">	upper_bound返回的是不能等于的数</span><br><span class="line">对结构体使用</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.value1 != b.value1) <span class="keyword">return</span> a.value1 &lt; b.value1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.value2 &lt; b.value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span>  f[N],a,g[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos1,pos2,cnt,len;</span><br><span class="line">	len=cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a) &#123;</span><br><span class="line">		pos1=upper_bound(f,f+len,a,greater&lt;<span class="keyword">int</span>&gt;())-f;</span><br><span class="line">		<span class="keyword">if</span>(pos1==len) f[len++]=a;</span><br><span class="line">		<span class="keyword">else</span> f[pos1]=a;</span><br><span class="line"> 		<span class="comment">//为什么包含等于非严格递增或递减的时候我们反而要用upper呢，这是因为这样子才能做到只有更小的节点才能更新len的长度</span></span><br><span class="line">		pos2=lower_bound(g,g+cnt,a)-g;</span><br><span class="line">		<span class="keyword">if</span>(pos2==cnt) g[cnt++]=a;</span><br><span class="line">		<span class="keyword">else</span> g[pos2]=a;</span><br><span class="line">        <span class="comment">//这里是严格递增的，所以用lower_bound</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="187-导弹防御系统"><a href="#187-导弹防御系统" class="headerlink" title="187.导弹防御系统"></a>187.导弹防御系统</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这是一道df题目，虽然披着LIS的皮，对于每一个点，我们都有两种选择：放到上升子序列集合或者下降子序列集合之中</p>
<p><a href="https://www.acwing.com/solution/AcWing/content/4010/" target="_blank" rel="noopener">这个分析的太好了</a></p>
<p>注意事项：</p>
<ol>
<li>可以使用<code>while(!dfs(depth,0,0,0))depth++</code>,这里的代码使用的是当dfs首次满足条件t==n（所有的点全部都集合之中）且集合数之和小于总数之和时对应的集合数之和的最小值，同样可以满足要求</li>
<li>必须要回溯，<code>temp=h[i](d[i])...h[i](d[i])=temp</code>否则会对之后的结果造成影响</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d, <span class="keyword">int</span> t)</span>  <span class="comment">//u表示上升的系统个数，d表示下降的系统个数,t表示第t个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u + d &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(t ==  n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u + d &lt; ans)ans = u + d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= u; i++)  <span class="comment">//找到第一个末尾数小于a[t]的导弹系统</span></span><br><span class="line">        <span class="keyword">if</span>(up[i] &lt; a[t])<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = up[i];</span><br><span class="line">    up[i] = a[t];<span class="comment">//添加到该导弹系统中</span></span><br><span class="line">    dfs(<span class="built_in">max</span>(u, i), d, t + <span class="number">1</span>);</span><br><span class="line">    up[i] = temp;  <span class="comment">//恢复现场</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++)<span class="comment">//找到第一个末尾数大于a[t]的导弹系统</span></span><br><span class="line">        <span class="keyword">if</span>(down[i] &gt; a[t])<span class="keyword">break</span>;</span><br><span class="line">    temp = down[i];</span><br><span class="line">    down[i] = a[t];<span class="comment">//添加到该导弹系统中去</span></span><br><span class="line">    dfs(u, <span class="built_in">max</span>(d, i), t + <span class="number">1</span>);</span><br><span class="line">    down[i] = temp;<span class="comment">//恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        ans = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="272-最大公共子序列"><a href="#272-最大公共子序列" class="headerlink" title="272.最大公共子序列"></a>272.最大公共子序列</h2><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.acwing.com/problem/content/274/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/274/</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>状态分析：</p>
<p>对于Ai,Bj,有</p>
<p>当Ai != Bj时，有f[i,j]==f[i-1,j];</p>
<p>当Ai == Bj时，有F[i,j]=max(0&lt;=k&lt;j,Bk&lt;Bj){f[i-1,k]}+1</p>
<p>可以使用三重循环来得到解，但其实应该有优化，我们思考k，实际上每一次当第二层移动时，a[i]是不动的，对于b[j]，如果它小于当前a[i],那么他的上一层a[i-1] [j]就有可能变成a[i] [j]的父节点，我们用maxv将当前a[i] [j]对应的最大的a[i-1] [k]用一个数字存起来就行了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> maxv=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j])	f[i][j]=maxv+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> f[i][j]=f[i][j];</span><br><span class="line">    	<span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            maxv=maxv(maxv,f[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>acwing</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 633 div.2&amp;&amp; round 634 div.3回顾</title>
    <url>/2020/04/15/codeforces-round-633-div-2-round-634-div-3%20round%20635%20div.2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>codeforces上的比赛一直都很多，索性一次性将有价值的题目全部都放到一起来写了</p>
<a id="more"></a>

<h2 id="round-633"><a href="#round-633" class="headerlink" title="round 633"></a>round 633</h2><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：给定指定的n个点，n-1条无向路（也就是说没有成环的可能），可以给路径随机分配正权值，从一个叶节点走到另外的叶节点路途中，所途径权值异或之和应该为零，问权值数量最少为多少，最多为多少</p>
<p>分析：首先我们先判断最小值的情况，我们可以发现，如果存在有两个节点之间的边数为奇数，那么权值的种类最小数必定为三，然后再去判断最大值的情况，两个或者两个以上叶节点同时连在了一个点上的情况中，这几个叶结点的权值边应该全部相同，所以只需要保留一个就可以了，把删掉的节点数用一个数字存起来，最大值就是 n-1-该数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,ans=<span class="number">0</span>,fl=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100005</span>],one;</span><br><span class="line"><span class="keyword">int</span> qi=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">-1</span>&amp;&amp;v[x].<span class="built_in">size</span>()==<span class="number">1</span>)&#123;	<span class="comment">//从所有的叶节点出发，到其他的的叶节点，判断路径的奇偶</span></span><br><span class="line">        <span class="keyword">if</span>(z%<span class="number">2</span>) ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,v[x].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x][i]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v[x][i],x,z+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> minn=<span class="number">0</span>,maxn=n<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        v[a].push_back(b);</span><br><span class="line">        v[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i].<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;qi==<span class="number">0</span>)&#123;</span><br><span class="line">            qi=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,v[i].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;			<span class="comment">//删除多余叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(v[v[i][j]].<span class="built_in">size</span>()==<span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>) fl+=cnt<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(qi,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>) minn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minn=<span class="number">3</span>;</span><br><span class="line">    maxn-=fl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minn,maxn);</span><br></pre></td></tr></table></figure>

<h2 id="round-634"><a href="#round-634" class="headerlink" title="round 634"></a>round 634</h2><h3 id="E1题"><a href="#E1题" class="headerlink" title="E1题"></a>E1题</h3><p>题意：给定一个数组，问在不改变顺序的情况下，通过删减数组中元素，使得数组变成’ABA’型回文串是否可能，如果可能，请输出最大的回文串的长度</p>
<p>分析：dp题，用数组从左往右遍历，用a[i] [j]表示当前位置 j 情况下字符 i 的数量，然后再用从每一个位置开始，</p>
<p>以当前位置为左端，设置右端，再遍历26个字母的存在，使得</p>
<p>maxin=max(maxin,a[i] [r+1]-a[i] [l]);</p>
<p>maxout=max(maxout,min(a[i] [l],a[i] [n]-a[i] [r+1])*2);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) int((a).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; int(n); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fore(i, l, r) for (int i = int(l); i &lt; int(r); ++i)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : a) <span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">		forn(i, n) &#123;</span><br><span class="line">			forn(j, <span class="number">26</span>) cnt[j][i + <span class="number">1</span>] = cnt[j][i];</span><br><span class="line">			++cnt[a[i] - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		forn(i, <span class="number">26</span>) ans = <span class="built_in">max</span>(ans, cnt[i][n - <span class="number">1</span>]);</span><br><span class="line">		forn(l, n) fore(r, l, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> cntin = <span class="number">0</span>, cntout = <span class="number">0</span>;</span><br><span class="line">			forn(el, <span class="number">26</span>) &#123;</span><br><span class="line">				cntin = <span class="built_in">max</span>(cntin, cnt[el][r + <span class="number">1</span>] - cnt[el][l]);</span><br><span class="line">				cntout = <span class="built_in">max</span>(cntout, <span class="built_in">min</span>(cnt[el][l], cnt[el][n] - cnt[el][r + <span class="number">1</span>]) * <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cntin + cntout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 632 Div.2回顾</title>
    <url>/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ</p>
<a id="more"></a>

<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p> <a href="https://codeforces.com/contest/1333" target="_blank" rel="noopener">https://codeforces.com/contest/1333</a></p>
<h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><p>一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'W'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'B'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><p>给定上下两个序列，上面一个序列可以进行一种运算:</p>
<p>对任意i &lt; j ,可以使得aj = ai+aj </p>
<p>要求是能否通过这种运算使得上面的数列等于下面的，其实就是找上面数列的1和-1的位置，再和每一位进行比对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod9 998244353</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,m,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vis[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">                <span class="keyword">if</span>(b[i]&gt;a[i]&amp;&amp;vis[<span class="number">0</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[i]&lt;a[i]&amp;&amp;vis[<span class="number">1</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">1</span>) vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">-1</span>) vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><p>题意给定一个序列，只能从左端或者右端截取一段走形成新的子序列，不存在可以从中间直接拿取（我就理解错了），所以这样子算来实际的序列数量是1+2+…..n，即 (n+1)*n/2 ,只要子序列中任意一个存在和为零的情况，那么这个序列就不符合要求，结果求得是符合要求的序列的数量，刚开始我还以为是一个求子序列和的问题，没有特别多的思路就选择做了后面的题目，毕竟2^n难以处理，结果因为传达了错误的题意还坑了和自己的一起写的大佬（捂脸）</p>
<p>处理：由于其子序列取得方式，我们可以推理，假设一个序列和为零，那么其右端所有序列（即母序列）也不符合要求，进一步想，我们会发现，假设从左往右计数求和sum，如果sum的值出现了两次，那么说明中间一段必定为和为零的序列，所以可以使用map<int int >记录下每个sum出现的最新位置，如果出现了重复的sum,就对其右边的母序列进行清除。不用注意重复子序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>,n,sum=<span class="number">0</span>,cnt=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成1，避免首元素就是0的情况</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.count(sum))&#123;</span><br><span class="line">        	cnt=<span class="built_in">max</span>(cnt,mp[sum]);</span><br><span class="line">		&#125;</span><br><span class="line">        ans+=i-cnt;</span><br><span class="line">        mp[sum]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成i+1,剪掉0子序列的首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h2><p>将序列当中全部向左转的跳到左边，右转的调到右边，这里看到了一位学长的代码，非常熟练地使用了各种STL，我从中学到了很多新的东西，比如范围for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;type&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:k)	<span class="built_in">cout</span>&lt;&lt;n;</span><br></pre></td></tr></table></figure>

<p>题解如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,k,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        p.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'R'</span>&amp;&amp;a[i+<span class="number">1</span>]==<span class="string">'L'</span>) </span><br><span class="line">                p.push_back(i++),swap(a[i],a[i<span class="number">-1</span>]),</span><br><span class="line">            	flag=<span class="literal">false</span>,sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        q.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k||sum&lt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d:q)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,d.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:d) <span class="built_in">printf</span>(<span class="string">" %d"</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树和平衡树初步</title>
    <url>/2020/05/04/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p> 终于划水划到平衡树了，学完了就先去做题，不强看书了,囫囵吞枣的学法难受且不实在，我是勤劳的进阶指南搬运工</p>
<a id="more"></a>

<h2 id="BST-二叉查找树"><a href="#BST-二叉查找树" class="headerlink" title="BST(二叉查找树)"></a>BST(二叉查找树)</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>对于任意一个节点，都能满足两个条件</p>
<ol>
<li>该节点的关键码不小于它的左子树任意节点的关键码</li>
<li>该节点的关键码不大于它的右子树任意节点的关键码</li>
</ol>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>首先建立两个其实节点，其关键码分别为无穷小和无穷大</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> tot,root,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	a[++tot].val=val;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">new</span>(INF),<span class="keyword">new</span>(-INF);</span><br><span class="line">    root=<span class="number">1</span>,a[<span class="number">1</span>].r=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>寻找二叉树是否存在关键码为val的节点</p>
<ol>
<li><p>若p的关键码为val，表示已经找到</p>
</li>
<li><p>若p的关键码大于val</p>
<ol>
<li>若p的左节点为空，说明不存在val</li>
<li>若p的左节点不为空，在左子树中进行递归查找</li>
</ol>
</li>
<li><p>若p的关键码小于val，和上一步正好反过来</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//左右节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(val==a[p].val) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> val&lt; p.val? <span class="built_in">get</span>(p.l,val):<span class="built_in">get</span>(p.r,val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在发现要走的节点为空是，直接插入新的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> val)</span>	</span>&#123;	<span class="comment">//引用</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span>(p,val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[p].val==val) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[p].val&lt;val) insert(a[p].r,val);</span><br><span class="line">    <span class="keyword">else</span> insert(a[p].l,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求前驱后继"><a href="#求前驱后继" class="headerlink" title="求前驱后继"></a>求前驱后继</h3><p>求后继：val的后继指的是在BST中关键码大于val的情况下，关键码最小的节点</p>
<ol>
<li>没有找到val,说明val的后继已经在所遍历的节点中，ans即为所求</li>
<li>找到了关键码为val的节点p,且该节点没有右子树，结果和1一样</li>
<li>找到了val节点p，从它的右子节点开始遍历，从左走，就找到了val的后继</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnext</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;	<span class="comment">//a[w].val=INF;</span></span><br><span class="line">    <span class="keyword">int</span> p=root;	<span class="comment">//root=1,v[root].val是-INF</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val==a[p].val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p].r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                p=a[p].r;</span><br><span class="line">                <span class="keyword">while</span>(a[p].l&gt;<span class="number">0</span>)	p=a[p].l;</span><br><span class="line">                ans=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[p].val&gt;val&amp;&amp;a[p].val&lt;a[ans].val)	ans=p;</span><br><span class="line">        p=val&lt;a[p].val?a[p].l:a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h3><ol>
<li>现在节点中寻找val,得到节点p</li>
<li>若p的子节点数小于二，那么直接删除P，令p的子节点代替p的位置</li>
<li>若p既有左子树又有右子树，那么就先求出val的后继节点next,然后直接删除next(没有左子树)，并令next的右子树代替next的位置，最后让next节点代替p，删除p即可</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> &amp;p=root;	<span class="comment">//先找寻val</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;	</span><br><span class="line">        <span class="keyword">if</span>(val==a[p].val) <span class="keyword">break</span>;</span><br><span class="line">        p=val&lt;a[p].val?a[p].l:a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span>;	<span class="comment">//不存在</span></span><br><span class="line">    <span class="keyword">if</span>(a[p].l==<span class="number">0</span>)&#123;	<span class="comment">//没有左子树，直接右子树代替</span></span><br><span class="line">        p=a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[p].r==<span class="number">0</span>)&#123;<span class="comment">//没有右子树，左子树代替</span></span><br><span class="line">        p=a[p].l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//左右子树都有</span></span><br><span class="line">        <span class="keyword">int</span> next=a[p].r;<span class="comment">//找后继</span></span><br><span class="line">        <span class="keyword">while</span>(a[next].l&gt;<span class="number">0</span>) next=a[next].l;</span><br><span class="line">        <span class="built_in">remove</span>(a[next].val);<span class="comment">//next节点必定没有左节点，删掉即可</span></span><br><span class="line">        a[next].l=a[p].l,a[next].r=a[p].r;</span><br><span class="line">        <span class="comment">//next继承p的左右节点</span></span><br><span class="line">        p=next;<span class="comment">//删除p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>满足二叉查找树性质且左右子树大小达到平衡，从而使得整棵树的深度维持在O(logN)级别</p>
<h4 id="treap左右旋"><a href="#treap左右旋" class="headerlink" title="treap左右旋"></a>treap左右旋</h4><p>假设x是y的左子节点，AB分别是x的左右子树，C是y的右子树</p>
<p>在维持BST的基础上，把x变成y的父节点。y变成x的右子树，B变成y的左子树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;y)</span></span>&#123;	<span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">int</span> x=a[y].l;	<span class="comment">//把x求出</span></span><br><span class="line">    a[y].l=a[x].r,a[x].r=y;	<span class="comment">//交换左右树</span></span><br><span class="line">    y=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=a[y].r;</span><br><span class="line">    a[y].r=a[x].l,a[x].l=y;</span><br><span class="line">    y=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.acwing.com/problem/content/255/" target="_blank" rel="noopener">普通平衡树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ycx的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">int</span> cnt, <span class="built_in">size</span>;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].<span class="built_in">size</span> = tr[tr[p].l].<span class="built_in">size</span> + tr[tr[p].r].<span class="built_in">size</span> + tr[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_node</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[ ++ idx].key = key;</span><br><span class="line">    tr[idx].val = rand();</span><br><span class="line">    tr[idx].cnt = tr[idx].<span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q;</span><br><span class="line">    pushup(tr[p].r), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span>    <span class="comment">// 左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">    <span class="comment">//之前一直对这个东西保有疑惑，后面发现必须要配合insert(&amp;p,val)和remove(&amp;p，key)来理解</span></span><br><span class="line">    pushup(tr[p].l), pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_node(-INF), get_node(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">    pushup(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">1</span>].val &lt; tr[<span class="number">2</span>].val) zag(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = get_node(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) zig(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) zag(p);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt -- ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l || tr[p].r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)</span><br><span class="line">            &#123;</span><br><span class="line">                zig(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                zag(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line"></span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 通过数值找排名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt; key) <span class="keyword">return</span> get_rank_by_key(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt + get_rank_by_key(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rank)</span>   <span class="comment">// 通过排名找数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;     <span class="comment">// 本题中不会发生此情况</span></span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> &gt;= rank) <span class="keyword">return</span> get_key_by_rank(tr[p].l, rank);</span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].<span class="built_in">size</span> + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> get_key_by_rank(tr[p].r, rank - tr[tr[p].l].<span class="built_in">size</span> - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_prev</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>   <span class="comment">// 找到严格小于key的最大数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt;= key) <span class="keyword">return</span> get_prev(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, get_prev(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> key)</span>    <span class="comment">// 找到严格大于key的最小数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt;= key) <span class="keyword">return</span> get_next(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, get_next(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) insert(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_rank_by_key(root, x) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_key_by_rank(root, x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_prev(root, x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_next(root, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小记-2020-5-4"><a href="#小记-2020-5-4" class="headerlink" title="小记(2020.5.4)"></a>小记(2020.5.4)</h2><p>二叉查找加treap平衡树，blog已经更新（抄y总代码），说实话，只是看了一遍代码，能基本的运用都不熟练，更别说变化了，可能是我对难度的估计太过乐观，明天还是回头把线段树有关的内容补完吧，要一步一步地来，一口吃不成胖子</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 636 div.2回顾</title>
    <url>/2020/04/22/codeforces-round-636-div-2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>昨晚的比赛感觉更像是div.2了。。。分类有点古怪</p>
<a id="more"></a>

<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p>重要代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m%sum)&#123;</span><br><span class="line">	k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    sum+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>一道dp题目，但是更加直观的可能是模拟，列出四种情况，判断进行的操作，代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : a) <span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = a[i];</span><br><span class="line">			<span class="keyword">int</span> j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; sgn(a[i]) == sgn(a[j])) &#123;</span><br><span class="line">				cur = <span class="built_in">max</span>(cur, a[j]);</span><br><span class="line">				++j;</span><br><span class="line">			&#125;</span><br><span class="line">			sum += cur;</span><br><span class="line">			i = j - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>这道题乍看起来不是很好操作，可以操作的点实在是太多了，但是我们可以观察到，对于一对数字a[i]和a[n-i+1]来说，最终的改变情况可能有四种(2^2)，综合来看我们可以得到最终总和的变化范围是</p>
<p>2-min(a[i],a[n-i+1])+1-a[i]+a[n-i+1]-max(a[i],a[n-i+1])+k-k*2(此处默认理想范围，不理想也没关系)</p>
<p>这里为什么是范围呢，因为我们并不能知道其他的元素能将这对数字变成具体的某个数字，只能确定的那个大概的范围，我们可以知道，如果出在了第一个阶段和第三个阶段，那么改变了两个数字，如果是处在第二阶段中，那么就是改变了一个数字，我们只要在2~k中处理前缀和，得到最终结果就可以了</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt[<span class="number">1</span>]+=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//初始化为2，此时是最低值2的前缀，默认改变两次</span></span><br><span class="line">			cnt[<span class="built_in">min</span>(a[i],a[n-i+<span class="number">1</span>])+<span class="number">1</span>]--;</span><br><span class="line">            <span class="comment">//当遇到低值至最高的范围中时没必要再改变两个，改变不在边上的就好了</span></span><br><span class="line">			cnt[<span class="built_in">max</span>(a[i],a[n-i+<span class="number">1</span>])+k+<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">//超出最大最小值能够够得着的范围，只能两个都改变</span></span><br><span class="line">			cnt[a[i]+a[n-i+<span class="number">1</span>]]--;</span><br><span class="line">            <span class="comment">//特判，当遇到不需要改变值的情况</span></span><br><span class="line">			cnt[a[i]+a[n-i+<span class="number">1</span>]+<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">//结束特判</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k*<span class="number">2</span>;i++)</span><br><span class="line">        <span class="comment">//遍历，寻找k值，得到最小的ans</span></span><br><span class="line">		&#123;</span><br><span class="line">			cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,cnt[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h3><p>题意：无向图一张，求a到b到c最短需要多久，这个是已经给出了图，要我们找到最短路之后给他们设置给定的一组边长中的值，使得最短路仍然是最短路</p>
<p>分析：最短路，最短路，又是这玩意，看似好做，实则麻烦死。首先我们必须得到边权值全部为1时的最短路，再来给边路分配权值，对于由a-b-c这样的路径，对于图中的所有点n，都存在有路线先从a到n,再从n到b最后到c的情况，我们所要求的最小路径中最小权值必定优先满足n到b的路径，因为要经过其两次，也不是绝对的，比如当n到b的路径太长导致超过了其余的</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> nxt;</span><br><span class="line">&#125;e[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> t,n,m,a,b,c,edgenum,head[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">3</span>][<span class="number">200005</span>];</span><br><span class="line">ll p[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//头插法的链接表（就是链表）</span></span><br><span class="line">	e[++edgenum].to=v;</span><br><span class="line">	e[edgenum].nxt=head[u];</span><br><span class="line">	head[u]=edgenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span>*dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.push(st);</span><br><span class="line">	dis[st]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> node=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> hd=head[node];hd;hd=e[hd].nxt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> to=e[hd].to;</span><br><span class="line">			<span class="keyword">if</span>(!dis[to])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[to]=dis[node]+<span class="number">1</span>;</span><br><span class="line">				q.push(to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)head[i]=dis[<span class="number">0</span>][i]=dis[<span class="number">1</span>][i]=dis[<span class="number">2</span>][i]=<span class="number">0</span>;</span><br><span class="line">		edgenum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line">		sort(p+<span class="number">1</span>,p+m+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i]+=p[i<span class="number">-1</span>];</span><br><span class="line">           	<span class="comment">//这里存好长度为i的路径对应的最小值</span></span><br><span class="line">			<span class="keyword">int</span> u,v;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">			add(u,v);</span><br><span class="line">			add(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(a,dis[<span class="number">0</span>]);</span><br><span class="line">		bfs(b,dis[<span class="number">1</span>]);</span><br><span class="line">		bfs(c,dis[<span class="number">2</span>]);</span><br><span class="line">		ll ans=<span class="number">1e18</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][i]+dis[<span class="number">2</span>][i]<span class="number">-3</span>&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//这个点，应该就是规避n到b的路径过长的问题吧，但是感觉没后面的好使</span></span><br><span class="line">			ans=<span class="built_in">min</span>(ans,p[dis[<span class="number">1</span>][i]<span class="number">-1</span>]+p[dis[<span class="number">0</span>][i]<span class="number">-1</span>+dis[<span class="number">1</span>][i]<span class="number">-1</span>+dis[<span class="number">2</span>][i]<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//配合p[i]对应的最小值，起飞</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈问题：寻找最大矩形面积</title>
    <url>/2020/04/12/%E5%8D%95%E8%B0%83%E5%A0%86%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 单调堆和队列可以对分析进行优化</p>
<a id="more"></a>

<h2 id="单调堆："><a href="#单调堆：" class="headerlink" title="单调堆："></a>单调堆：</h2><p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ2559</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[n+<span class="number">1</span>]=p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;s[p])</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">width</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[p]&gt;a[i])&#123;		</span><br><span class="line">			<span class="built_in">width</span>+=w[p];</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">width</span>*s[p]);</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="built_in">width</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最大子序和：给定一个长为N的整数序列，求找到一段不超过M的连续子序列，使得子序列中的所有数的和为最大值。N,M&lt;+3*10^5</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们思考一下，对于任意一个点i,以它结尾的子序列的的首位j一定存在如下情况：在不超过i的前置位M的情况下，s[j]一定是最小的，直到i右移，有新的单元s[i]加入能够替换s[j]或者超过最大限度M不得不换更右边的数字.</p>
<p>这里我们得用到单调递减序列，最优选择的序列集合一定是“下标位置递增，对应的前缀和的值也递增的”序列。我们这里使用一个一队列来保存这个序列。</p>
<p>操作如下：</p>
<ol>
<li>判断队头决策与i的距离是否超出M的范围，若超出则出队</li>
<li>此时对头就是右端点为i时，左端点的最优选择</li>
<li>不断删除队尾决策，直到队尾对应的S值小于等于s[i] 。然后把i作为一个新决策入队</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">//初始化在首位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-m)	l++;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,sum[i]-sum[q[l]]);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r&amp;&amp;sum[q[r]]&gt;=sum[i])	r--;</span><br><span class="line">    <span class="comment">//如果s[i]最小，相当于清空了队列。。</span></span><br><span class="line">    q[++r]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>可持续化数据结构</title>
    <url>/2020/05/07/%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>便于得知数据集过去状态的一种方式，假设存在m次变化，当我们想知道过去的所有情况下的变化时，可以将数据结构拷贝一份，多耗费m倍空间</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>同余</title>
    <url>/2020/04/13/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<p>最近一次的周赛中暴露了同余逆元的短板，连板子都不会用，哎，只能加紧补了</p>
<a id="more"></a>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果a,b对正整数n的余数相等，那么a≡b(mod n)</p>
<h3 id="同余类和剩余类"><a href="#同余类和剩余类" class="headerlink" title="同余类和剩余类"></a>同余类和剩余类</h3><p>对于所有a∈ [0,m-1], 集合 {a+km}对于m同余，该集合称为一个m的同类余，一个模m的同类余一共有{0,1,…..m-1}共m个，被称为完全剩余系</p>
<p>完全剩余系中与m互质的同类余有φ(m)个，被称为m的简化剩余系，简化剩余系的积也是m的简化剩余系</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若p是质数，则对于任意正整数a，有a^p≡a(mod p)</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若正整数 a,n互质，那么a^φ(n)≡1(mod n),其中φ(n)是欧拉函数(不超过n的简化剩余系元素)</p>
<p>推论：</p>
<p>若正整数a ,n互质,对于任意正整数b，</p>
<p>有:  a^b≡a^(b mod φ(n)) (mod n)</p>
<p>这些定理的证明链接：<a href="https://www.cnblogs.com/zylAK/p/9569668.html" target="_blank" rel="noopener">https://www.cnblogs.com/zylAK/p/9569668.html</a></p>
<p>快速幂取余的板子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mod</span><span class="params">(LL a,LL b,LL mod)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="comment">//b==1</span></span><br><span class="line">            ans=ans*a%mod；</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别情况：当a，n不一定互质的且b&gt;φ(n)情况下，可以有：</p>
<p>a^b≡a^(b modφ(n)+φ(n)) (mod n)</p>
<p>例题：<a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">POJ3696</a></p>
<p>最近发现欧拉定理的拓展不能用在快速幂板子，会导致答案错误，是一把双刃剑</p>
<h3 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h3><p>某打不出名字的定理：</p>
<p>对于任意整数a,b,存在一对整数x,y,满足 ax+by == gcd(a,b)</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123; x=<span class="number">1</span>,y=<span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> z=x; x=y; y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>若整数 b,m互质，并且 b|a，则存在一个整数x，使得a/b≡a*x(mod m),则x称为b的模m乘法逆元，记为b ^-1(mod m)</p>
<p>当模数m为质数时，b^m-2即为b的乘法逆元</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构 KMP模式匹配</title>
    <url>/2020/04/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>KMP匹配是判断两个线性表之间是否存在子母串关系的算法，并且能够定位到子串所处的位置</p>
<a id="more"></a>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1 .首先对小的字符串A进行自我”匹配”，设置next数组，其中next[i]表示“A中以a[i]结尾的非前缀子串”与”A的前缀”所能匹配到的最大长度</p>
<p>公式： next[i]=max{j},其中j&lt;i并且A[i-j+1 ~ i]==A[1 ~ j]</p>
<p>特别的：当不存在这样的 j 时，令next[i]=0</p>
<p>2 .对字符串A和B进行匹配，求出一个数组f，其中f[i]表示“B中以i结尾的字串”与”A的前缀”能够匹配到的最大长度</p>
<p>公式： f[i]=max{j},其中j&lt;i并且B[i-j+1 ~i]==A[1 ~ j]</p>
<p>当j的长度超过了n时，应该把j=next[j];</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于j&lt;i,则j是next[i]的一个候选项，则小于j的next[i]的最大候选项是next[j],这是一个套娃的关系，直到满足条件或者next[j]==0</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next数组的求法</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>]) j=next[j];</span><br><span class="line">    <span class="comment">//找到符合条件的j,或者j==0;</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]==a[j+<span class="number">1</span>]) j++; </span><br><span class="line">    <span class="comment">//如果符合条件，加上末尾的元素</span></span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f数组的求法（大同小异）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(j==n||b[i]!=a[j+<span class="number">1</span>])) j=next[j];</span><br><span class="line">    <span class="keyword">if</span>(b[i]==a[j+<span class="number">1</span>]) j++;</span><br><span class="line">	f[i]=j;</span><br><span class="line">    <span class="comment">//当f[i]==n的时候，说明子串就出现了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ1961</a></p>
<p>题意：求循环元，首先我们设s[1~i]拥有长度为len的循环元</p>
<p>那么len必定满足以下条件：</p>
<p>len|i &amp;&amp; s[len+1<del>i]==s[1</del>i-len]</p>
<p>而最小循环节则满足</p>
<p>s[len] (最小循环节)=next[i]</p>
<p>综上，得到代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[j+<span class="number">1</span>]!=a[i]) j=next[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i]) j++;</span><br><span class="line">        next[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">        calc_next();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test case"</span>&lt;&lt;++T&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>&amp;&amp;i/(i-next[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;i/(i-next[i])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何储存路径元素</title>
    <url>/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>图的路径追溯一直都是个比较麻烦的问题，这里写一下看到的储存方法</p>
<a id="more"></a>

<h2 id="最短路路径"><a href="#最短路路径" class="headerlink" title="最短路路径"></a>最短路路径</h2><p>题目链接：<a href="http://poj.org/problem?id=1734" target="_blank" rel="noopener">POJ1734</a></p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图使用floyd，最小环长度应该是：</p>
<p>min( 1&lt;= i&lt; j &lt; k) {d[i,j] + a[i,k] + a[k,j]}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],d[N][N],pos[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    get_path(x,pos[x][y]);</span><br><span class="line">    path,push_back(pos[x][y]);</span><br><span class="line">    get_path(pos[x][y],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[y][x]=a[x][y]=<span class="built_in">min</span>(a[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(d,a,<span class="keyword">sizeof</span> a);	<span class="comment">//这波很骚；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;ik&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ki++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]+a[i][k]+a[k][j]&lt;ans)&#123;</span><br><span class="line">                    ans=d[i][j]+a[i][k]+a[k][j];</span><br><span class="line">                    path.<span class="built_in">clear</span>();</span><br><span class="line">                    path.push_back(i);</span><br><span class="line">                    get_path(i,j);</span><br><span class="line">                    path.push_back(j);</span><br><span class="line">                    path.push_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]&gt;d[i][k]+d[k][j])&#123;</span><br><span class="line">                    d[i][j]=d[i][k]+d[k][j];</span><br><span class="line">                    pos[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了pos[i] [j]这个矩阵存储了两个点之间的中间路径，同时get_back函数通过递归调用再次得出i与k,k与j之间的关系，但是注意，这个方法只能存储最短路的路径，不能存储所有的路径。。。</p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图使用二分堆优化的dijkstra,同样是使用pos存储中间节点，方法：枚举1-n之间的起点s,从s开始出堆，但是s出堆之后立刻将d[s]设置为无穷大，这样子s第二次入堆时得到的就是最小有向环</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树&amp;树状数组初学</title>
    <url>/2020/05/02/%E7%BA%BF%E6%AE%B5%E6%A0%91&amp;%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E5%AD%A6/</url>
    <content><![CDATA[<p>鼓捣了三天才勉强算是入个门，这里就算是借大佬们的代码来给自己加深一下理解吧</p>
<a id="more"></a>

<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p>这里是一个序列求和的板子，算是最基础的吧，含lazy</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10000</span>;      <span class="comment">//这个板子应该是求区间和的经典板子</span></span><br><span class="line"><span class="keyword">int</span> _;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll l,r,w,flag;</span><br><span class="line">    node() &#123;&#125;;</span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r,<span class="keyword">int</span> _w,<span class="keyword">int</span> _f)   &#123;flag=_f,l=_l,r=_r,w=_w;&#125;</span><br><span class="line">    <span class="function">ll <span class="title">mid</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (l+r)/<span class="number">2</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node a[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll k,ll l,ll r)</span></span>&#123;</span><br><span class="line">    a[k]=node(l,r,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//新的区间</span></span><br><span class="line">    <span class="keyword">if</span>(a[k].l==a[k].r)&#123; <span class="comment">//找到叶节点，将输入的值输进去，这里面很巧妙的使用了先建立左边板子的条件</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[k].w;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//叶节点不再存在有子节点，直接回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    build(k&lt;&lt;<span class="number">1</span>,l,(l+r)/<span class="number">2</span>);  <span class="comment">//此处依然不是根节点，找左边的子区间</span></span><br><span class="line">    build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,(l+r)/<span class="number">2</span>,r);    <span class="comment">//找右边的的子区间</span></span><br><span class="line">    a[k].w=a[k&lt;&lt;<span class="number">1</span>].w+a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].w;   <span class="comment">//当左右两边的子区间的值都求出来之后，就可以求父区间的值了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;   <span class="comment">//这里是延迟标记。。。相当于把原本应该加上去的值给传递下去，之前是因为访问太麻烦了</span></span><br><span class="line">    a[k&lt;&lt;<span class="number">1</span>].flag+=a[k].flag;    <span class="comment">//左端子节点加上父节点的标记值</span></span><br><span class="line">    a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].flag+=a[k].flag;  <span class="comment">//现在是右节点</span></span><br><span class="line">    a[k&lt;&lt;<span class="number">1</span>].w+=a[k].flag*(a[k&lt;&lt;<span class="number">1</span>].r-a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>); <span class="comment">//价值等于父节点的标记值加上自己的元素数量</span></span><br><span class="line">    a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].w+=a[k].flag*(a[k&lt;&lt;<span class="number">1</span>].r-a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>);<span class="comment">//现在是右边的节点</span></span><br><span class="line">    a[k].flag=<span class="number">0</span>;    <span class="comment">//取消标记，当前任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;   <span class="comment">//区间更新，k为访问到的子节点，x,y是改变的的区间，z是更新的值？</span></span><br><span class="line">    <span class="keyword">if</span>(a[k].l&gt;=x&amp;&amp;a[k].r&lt;=y)&#123;   <span class="comment">//当前区间被改变区间完全覆盖，应该全部加上z</span></span><br><span class="line">        a[k].w+=z*(a[k].r-a[k].l+<span class="number">1</span>);    </span><br><span class="line">        a[k].flag+=z;   <span class="comment">//继承标记，但是还没向下传递</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[k].flag)   <span class="comment">//如果之前已经出现了延迟标记，先将标记传递下去</span></span><br><span class="line">        down(k);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;a[k].mid())    <span class="comment">//没能完全覆盖，就只能继续寻找对应的子节点</span></span><br><span class="line">        update(k&lt;&lt;<span class="number">1</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;a[k].mid())    <span class="comment">//这是右节点</span></span><br><span class="line">        update(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,z);</span><br><span class="line">    a[k].w=a[k&lt;&lt;<span class="number">1</span>].w+a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].w;   <span class="comment">//当被改变区间能覆盖的最上层结果被改变之后，递归结束，上层的值也要被改变。延迟传递只能由上往下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;  <span class="comment">//查询一段区间的值</span></span><br><span class="line">    <span class="keyword">if</span>(a[k].l&gt;=x&amp;&amp;a[k].r&lt;=y)&#123;   <span class="comment">//覆盖就直接加上当前节点的值，没有必要继续往下</span></span><br><span class="line">        res+=a[k].w;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[k].flag)   <span class="comment">//没有覆盖，并且有标记标记，更新下一段</span></span><br><span class="line">        down(k);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=a[k].mid())   <span class="comment">//完成更新之后，找寻子节点当中符合标准的</span></span><br><span class="line">        query(k&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;a[k].mid())</span><br><span class="line">        query(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">    a[k].w=a[k&lt;&lt;<span class="number">1</span>].w+a[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].w;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="区间求最大值，线段树增加元素"><a href="#区间求最大值，线段树增加元素" class="headerlink" title="区间求最大值，线段树增加元素"></a>区间求最大值，线段树增加元素</h4><p>公式推导：</p>
<p>t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum;</p>
<p>t[p].lmax=max(t[p&lt;&lt;1].lmax,t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].lmax);</p>
<p>t[p].rmax=max(t[p&lt;&lt;1|1]rmax,tp[p&lt;&lt;1|1].sum+tp[p&lt;&lt;1].rmax);</p>
<p>t[p].dat=max(t[p&lt;&lt;1].dat,t[p&lt;&lt;1|1].dat,t[p&lt;&lt;1].rmax+t[p&lt;&lt;1|1].lmax);</p>
<p>这一题和经典板子的区别在于使用的pushup函数不一样，所以要设置两种pushup函数，一种情况用于建树，另一种用于查询</p>
<p><a href="https://www.acwing.com/problem/content/1277/" target="_blank" rel="noopener">acwing 1275.最大数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> sum, lmax, rmax, tmax;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;<span class="comment">//非常规情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pushup(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;<span class="comment">//常规情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> query(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = query(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            pushup(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> modify(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h4><p>链接：<a href="https://www.acwing.com/problem/content/249/" target="_blank" rel="noopener">亚特兰蒂斯</a></p>
<ol>
<li>首先用n个矩形的x,y轴端点来划分出区域</li>
<li>以x轴的坐标点之间的线段作为元素，y轴的作为扫描线，一个矩形的左端扫描线使得它所覆盖的区域cnt+1,右端cnt-1,用每段线段长度乘以它所处范围当中cnt&gt;=0的部分</li>
<li>最终全长即为目标值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y1, y2;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Segment &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>		//扫描线</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;	<span class="comment">//扫描线的上端下端</span></span><br><span class="line">    <span class="keyword">int</span> cnt;	<span class="comment">//扫描线是矩形左端还是右端</span></span><br><span class="line">    <span class="keyword">double</span> len;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt) tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) modify(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            seg[j ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">            seg[j ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            ys.push_back(y1), ys.push_back(y2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">        ys.erase(unique(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        sort(seg, seg + n * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">            modify(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\n"</span>, T ++ );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Total explored area: %.2lf\n\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态开点和线段树合并"><a href="#动态开点和线段树合并" class="headerlink" title="动态开点和线段树合并"></a>动态开点和线段树合并</h4><p><strong>从kevin那搞得，不然真的猝死了</strong></p>
<h5 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">2e14</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll t,sum,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rt,ls[N],rs[N],num[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;p,ll l,ll r,ll pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    num[p]++;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) update(ls[p],l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> update(rs[p],mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,ll l,ll r,ll L,ll R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> num[p];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) res+=query(ls[p],l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) res+=query(rs[p],mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;t);</span><br><span class="line">    update(rt,-inf,inf,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        sum+=m;</span><br><span class="line">        ans+=query(rt,-inf,inf,sum-t+<span class="number">1</span>,inf);</span><br><span class="line">        update(rt,-inf,inf,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合并线段树"><a href="#合并线段树" class="headerlink" title="合并线段树"></a>合并线段树</h5><p>两个维护相同值域的线段树，都含有log[n]次操作,那么我们可以将他们合并起来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)	<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">if</span>(!q) 	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p==q)&#123;</span><br><span class="line">        tr1[p].dat+=tr2[q].dat;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr1[p].lc=merge(tr1[p].lc,tr2[q].lc,l,mid);</span><br><span class="line">    tr1[p].rc=merge(tr1[p].rc,tr2[q].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">    tr1[p].dat=<span class="built_in">max</span>(tr1[tr[p].lc].dat,tr1[tr1[q].rc].dat);<span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h3 id="一阶"><a href="#一阶" class="headerlink" title="一阶"></a>一阶</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll x)</span></span>&#123;	<span class="comment">//求前缀和</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=x&amp;x)	ans+=c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y)</span></span>&#123;	<span class="comment">//单点增加</span></span><br><span class="line">	<span class="keyword">for</span>(;x&lt;=N;x+=x&amp;x) c[x]+=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树状数组与逆序对"><a href="#树状数组与逆序对" class="headerlink" title="树状数组与逆序对"></a>树状数组与逆序对</h3><p>求序列当中的逆序对有多少</p>
<ol>
<li>在序列的数字范围中建立树状数组，初始化为零</li>
<li>正序扫描给定的序列，对于每个序列中的数字a[i]<ol>
<li>在树状数组中查询前缀和c[n]-c[a[i]],累加到ans中</li>
<li>执行单点增加操作，即把a[i]位置上又加一次 </li>
</ol>
</li>
</ol>
<p>这个方法适合序列中的数据范围不大时的情况，复杂度为O(NlogM),否则应该使用归并排序的方法求逆序对</p>
<p><a href="https://www.acwing.com/problem/content/243/" target="_blank" rel="noopener">楼兰图腾</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> tr[N];</span><br><span class="line"><span class="keyword">int</span> Greater[N], lower[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//lowbit函数求最低位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span>  <span class="comment">//单点增加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//区间求和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = a[i];</span><br><span class="line">        Greater[i] = sum(n) - sum(y);</span><br><span class="line">        lower[i] = sum(y - <span class="number">1</span>);</span><br><span class="line">        add(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);   <span class="comment">//清空，再来</span></span><br><span class="line">    LL res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (LL)(sum(n) - sum(y));</span><br><span class="line">        res2 += lower[i] * (LL)(sum(y - <span class="number">1</span>));</span><br><span class="line">        add(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, res1, res2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树状数组适合单点增加和区间查询，如果实现区间增加和单点查询，可以建立一个差分树状数组，求其前缀和即为变化值</p>
<h2 id="2020-5-7-小记"><a href="#2020-5-7-小记" class="headerlink" title="2020.5.7 小记"></a>2020.5.7 小记</h2><p>从下定决心打好acm这个目标开始已经过去了一个月了，过去的一个月较以往来说确实是截然不同，我初次体会到了作为一个ACMer所体会到的生活，学习了一些基础的算法，cf也都一场不落地参加了，更重要的是认识到了一群共同努力的同龄人，在他们身上我看到了属于这个年龄段本该有的朝气和毅力，真心地佩服他们。这是我从高中毕业以来久久没有没有看到过的场景，只可惜那时我都沉湎于娱乐世界中不可自拔，以所谓的迷茫来做逃避和麻醉，其实青年人努力学习，挑战自我才是正确的旋律。ACM是一项纯粹的竞赛运动，重要的是我们在这段经历中体验到了什么，领悟到了什么，它的核心除了刺激的比赛和令人欲罢不能的题目外，更重要的是在这一次次训练，比赛外带来的酸甜苦辣，和自己谱写出的有关青春的篇章吧。</p>
<p>训练时间安排：</p>
<p>双休： 8：00——12：00   14：00——18：00    19：00——23：30</p>
<p>工作日：晚上时间相同，其余的按照课表空余来</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）bellman-ford和SPFA</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/</url>
    <content><![CDATA[<p>bellman-ford流程：</p>
<ol>
<li>扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y]</li>
</ol>
<p>重复以上步骤，直到没有更新步骤发生</p>
<p>复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra</p>
<a id="more"></a>

<p>SPFA:</p>
<ol>
<li><p>建立一个队列，最初队列中只有起点1</p>
</li>
<li><p>取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队</p>
</li>
<li><p>重复上面步骤，直到队列为空</p>
</li>
</ol>
<p>这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>(<span class="keyword">int</span>) q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>,v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],x=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!v[x])	q.push(y),v[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SPFA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是该方法对于边权存在为负数的边同样适用。</p>
<p>并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）两点间无向最短路径 floyd</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/</url>
    <content><![CDATA[<p>floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化</p>
<p>如果想要了解内部缘由不妨移步：<a href="https://www.zhihu.com/question/30955032/answer/68834307" target="_blank" rel="noopener">为什么k要放在最外层</a></p>
<a id="more"></a>

<p>设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。</p>
<p>得到公式：</p>
<p>D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j])</p>
<p>可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;				<span class="comment">//floyd的状态转移方程：d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]),可以转换成三重循环的。。 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		<span class="comment">//最外层循环是为了找到能不能有其他点帮助目标点完成最短路。。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                d[a[i]][a[j]]=d[a[j]][a[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum+=d[i][j];</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans*<span class="number">100</span>/(n<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递闭包：传递推导尽量多的元素之间的关系(感觉并查集也能解决相等的关系，但是大于小于不行)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]|=d[i][k]&amp;d[k][j];</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）单源最短路径：dijkstra</title>
    <url>/2020/04/04/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra/</url>
    <content><![CDATA[<p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p>
<a id="more"></a>

<ol>
<li>初始化d[1]=0,然后将其余的dist全部设置为最大</li>
<li>进行n-1次循环，每次都找最小了dist[x],将x标记</li>
<li>扫描该x的全部出边（x,y,z）,ifd[y]&gt;d[x]+z),更新d[y] </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[j]&amp;&amp;(x==<span class="number">0</span>||d[j]&lt;d[x]))	x=j;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		a[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="string">"x"</span>)&#123;</span><br><span class="line">				a[i][j]=a[j][i]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">					n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a[i][j]=a[j][i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		d[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	search();</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)…适用于求单源路径…<br>最优序列方法，之后更新…</p>
<p>categrories: </p>
<ul>
<li>ACM</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>（图论初学）邻接矩阵和邻接表</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<p>对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。</p>
<a id="more"></a>

<ol>
<li><p>邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。</p>
</li>
<li><p>邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。</p>
<p>插入和遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入有向边(x,y,z)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">    <span class="comment">//注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有x出发的有向边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;	</span><br><span class="line">    <span class="comment">//这里面的i如果为0.结束循环</span></span><br><span class="line">	<span class="keyword">int</span> y=ver[i],x=ver[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）单源最短路径-dijkstra</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/</url>
    <content><![CDATA[<p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p>
<a id="more"></a>

<ol>
<li>初始化d[1]=0,然后将其余的 distance 全部设置为最大</li>
<li>进行n-1次循环，每次都找最小了distance[x],将x标记</li>
<li>扫描该x的全部出边（x,y,z）,if d[y]&gt;d[x]+z),更新d[y] </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[j]&amp;&amp;(x==<span class="number">0</span>||d[j]&lt;d[x]))	x=j;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		a[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="string">"x"</span>)&#123;</span><br><span class="line">				a[i][j]=a[j][i]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">					n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a[i][j]=a[j][i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		d[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	search();</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，主要复杂度来自第一步对全局最小值的寻找，适用于求单源路径.</p>
<p>下面是使用二叉树堆对dist进行维护之后，可以在O(mlogn)的时间内实现dijkstra:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],next[M],d[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//注意这里的key值是dist值的相反数，因为要选取最小值，第二个值为对应的节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.top().second,q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],z=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 641&amp;&amp;642 回顾</title>
    <url>/2020/05/16/codeforces-round-641-642-%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>又到周末了，把最近打的cf没补的题目在假期补了，顺带水一发博客，感觉最近的cf没以前这么难了？</p>
<a id="more"></a>

<h3 id="round-641"><a href="#round-641" class="headerlink" title="round 641"></a>round 641</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://codeforces.com/contest/1350/problem/" target="_blank" rel="noopener">codeforces round 641</a></p>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p><strong>分析</strong>：找到序列两两组合形成的新的序列的最大公约数，其实观察我们可以知道这个数就是先找到原序列的最大公约数，然后再找到任意n-1个数与公约数之商组成的新的公约数的最大值，两者之积就是结果，时间复杂度O(n*logv)</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line">ll pre[maxn],suf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ga,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">	pre[<span class="number">1</span>]=a[<span class="number">1</span>]; suf[n]=a[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		pre[i]=gcd(pre[i<span class="number">-1</span>],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		suf[i]=gcd(suf[i+<span class="number">1</span>],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">			ans=suf[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">			ans=ans*pre[n<span class="number">-1</span>]/gcd(pre[n<span class="number">-1</span>],ans);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans=ans*gcd(pre[i],suf[i+<span class="number">2</span>])/gcd(gcd(pre[i],suf[i+<span class="number">2</span>]),ans);</span><br><span class="line">        <span class="comment">//求ans与gcd(pre[i],suf[i+2])的最小公倍数。。。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p><strong>分析</strong>：这道题虽然放在了这个位置，但是真正的难点就在能不能想到转化上，想到之后难度绝对低于C，原问题可以转化为能不能将原序列中的任意两个数变成连续的k，我们想一下，如何转化，实际上很简单，对于两个连续的值，得出的最终变换结果必定是当中较小的值，只需要找到初始位置上任意连续两点的值大于或者等于k就行了,按照这个思路，问题就迎刃而解了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n,k;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS ;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        pos.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">int</span> fl=<span class="number">1</span>,sig=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">              <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">              <span class="keyword">if</span>(a[i]^k)fl=<span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span>&#123;	<span class="comment">//找到和k相同的 </span></span><br><span class="line">                  sig=<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sig==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n<span class="number">-1</span> ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;k)<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(a[i+<span class="number">1</span>]&gt;=k||(i&lt;=n<span class="number">-2</span>&amp;&amp;a[i+<span class="number">2</span>]&gt;=k))&#123;</span><br><span class="line">                    fl=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fl)<span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="round-642"><a href="#round-642" class="headerlink" title="round 642"></a>round 642</h3><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://codeforces.com/contest/1353" target="_blank" rel="noopener">codeforces round 642O</a></p>
<h4 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h4><p>分析：单调队列+模拟，时间复杂度O(n*logn)，单调队列这个玩意实在有点玄学，至今不怎么会用，要临场学</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="comment">/* mt19937 mrand(random_device&#123;&#125;());</span></span><br><span class="line"><span class="comment">int rnd(int x) &#123; return mrand() % x;&#125;*/</span></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod;  <span class="keyword">for</span>(;b&gt;<span class="number">0</span>;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="number">48</span> || ch &gt; <span class="number">57</span>) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="number">48</span> &amp;&amp; ch &lt;= <span class="number">57</span>) s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,z,y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; b)<span class="keyword">const</span></span><br><span class="line">    <span class="comment">//重载'&lt;'号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u != b.u) <span class="keyword">return</span> u &lt; b.u;</span><br><span class="line">        <span class="comment">//长度优先</span></span><br><span class="line">        <span class="keyword">return</span> z &gt; b.z;</span><br><span class="line">        <span class="comment">//否则左节点靠前的优先</span></span><br><span class="line">    &#125;·</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; lpt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        lpt.push(&#123;n,<span class="number">1</span>,n&#125;);</span><br><span class="line">        k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lpt.<span class="built_in">size</span>())&#123;</span><br><span class="line">            node x=lpt.top();</span><br><span class="line">            lpt.pop();</span><br><span class="line">            <span class="keyword">int</span> l=x.z,r=x.y;</span><br><span class="line">            <span class="keyword">int</span> kevin=(l+r)/<span class="number">2</span>;</span><br><span class="line">            a[kevin]=k++;</span><br><span class="line">            <span class="keyword">if</span>(kevin!=l) lpt.push(&#123;(kevin-l),l,kevin<span class="number">-1</span>&#125;);</span><br><span class="line">            <span class="comment">//存左段</span></span><br><span class="line">            <span class="keyword">if</span>(kevin!=r) lpt.push(&#123;(r-kevin),kevin+<span class="number">1</span>,r&#125;);</span><br><span class="line">            <span class="comment">//存右段</span></span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><p>这回后面两题全部都是dp题目，甚至有时我觉得这两题的比div.2的C,D还要适合我的水准</p>
<p><strong>分析</strong>：对于E我们可以采取前缀和记录1的数量，对于每个字符串，我们都可以将它分成不同的三截，前后两节都是0，中间部分是长度为k的循环节，我们要做的事情，就是判断怎么将这个字符串分成我们想要的情况，我们仔细观察会发现，所有的变化都可以视为k种情况的变种，即从第i个开始有了循环节，由此我们先算出所有灯开着的数量，然后按照1~k不同出发点对其进行判断，只需要处理处在循环节点上的灯就可以得出结果了，这就是第一种解法，时间复杂度O(k*(n/k))==O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n , k , sum = <span class="number">0</span> , ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) sum += s[i] - <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &lt;= n ; j +=k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[j] == <span class="string">'1'</span>) cnt -- ;</span><br><span class="line">				<span class="keyword">else</span> cnt ++ ;</span><br><span class="line">				cnt = <span class="built_in">min</span>(cnt , <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//这个地方什么意思呢，就是当前情况下我们</span></span><br><span class="line">				ans = <span class="built_in">min</span>(ans , sum + cnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>  ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种解法是dp,看起来就不好理解，时间复杂度也是O(n)</p>
<p>dp [i] [0]表示在第i个点将其变成0情况下的最小值，dp [i] [1]反之，大概的意思和前面的是一样的</p>
<p>dp [i] [0]就是第一段和第三段的计算</p>
<p>dp [i] [1]是对于第二段的判断，重点在于</p>
<p>p=max(0,i-k)</p>
<p>和dp [i] [1] = min(pre[i-1],<strong>dp[i] [0]+pre[i-1]+pre[p]</strong>)+(s[i]==’0’)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N] , dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> t; </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n , k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) pre[i] = pre[i - <span class="number">1</span>] + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">//一样的前缀和操作，但是这次要保存每个点的状态</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p = <span class="built_in">max</span>(<span class="number">0</span> , i - k);</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] , dp[i - <span class="number">1</span>][<span class="number">1</span>]) + (s[i] == <span class="string">'1'</span>); </span><br><span class="line">			dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(pre[i - <span class="number">1</span>] , dp[p][<span class="number">1</span>] + pre[i - <span class="number">1</span>] - pre[p]) + (s[i] == <span class="string">'0'</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(dp[n][<span class="number">0</span>] , dp[n][<span class="number">1</span>]) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i ++) dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = pre[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><p><strong>分析</strong>：刚开始以为只是个简单的数字三角形模板的变化形态，结果就罚坐发呆了一小时，还没写出个所以然出来，结果以看题解，人都傻了，比我想得还是要复杂很多</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
</search>
