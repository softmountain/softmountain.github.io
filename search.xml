<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>codeforces edu round 85 A-D</title>
    <url>/2020/04/11/codeforces-edu-round-85-A-D/</url>
    <content><![CDATA[<p>昨晚的比赛并没有参加，但是今天早上参考大佬的代码，花时间把前面相对简单的四题给补了</p>
<a id="more"></a>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/contest/1334" target="_blank" rel="noopener">https://codeforces.com/contest/1334</a></p>
<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p>意思是进行一场游戏，会显示游戏次数和成功次数，由题意可知，游戏次数必定大于成功次数，然后问显示的数据是真是假，用几个条件判断一下就好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">1</span>,m1=<span class="number">0</span>,m2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(m1&gt;a[i]||m2&gt;b[i]||a[i]&lt;b[i]||b[i]-m2&gt;a[i]-m1)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m1=a[i],m2=b[i];	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p>题意：从一个序列里面随机抽取几个元素，使得这几个元素元素的平均数大于或等于目标值，问最多能抽取几个元素</p>
<p>首先排序(最大的在前面)，然后sum从左往右遍历，求和，如果一直满足条件ans++;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">101000</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,a[N],_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="comment">//这里使用scanf()函数对_进行赋值，然后直接_--，太骚了 </span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		reverse(a,a+n);			</span><br><span class="line">		<span class="comment">//大佬的代码简洁，不写cmd，直接reverse满足 </span></span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		ll s=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			s+=a[i];</span><br><span class="line">			<span class="keyword">if</span> (s&gt;=(ll)(i+<span class="number">1</span>)*x) ans=i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>题意：有一群怪物将作者围在中间，每个怪物分别拥有生命值和爆炸值两个数值，怪物死亡时会爆炸，对下一个怪物造成自己爆炸值数值的伤害(如果是最后一个，那么就是第一个，因为围成了圈)，求最低造成多少伤害，就能够将所有的怪物清除。</p>
<p>分析：对下一个怪物的伤害不会超过下一个怪物的生命值，所以杀死一个怪物的代价应该是</p>
<p>penalty=min(0,a[i]-b[i+n-1%n])    (前面的一个怪物已经被引爆的情况)</p>
<p>原本我是想用优先队列来写的，计算一个怪物的生命值和爆炸最多能对下一个怪物造成的伤害之和为序不停从堆中抽取，后来发现实际上怪物的生命值是动态的，不能用静态的生命值来算，只能作罢。看了别人的代码，才恍然大悟，这是一道贪心题，但是计算的应该是消灭一个怪物所要付出的代价而不是所能造成的最大化伤害。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">ll extra[N],a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		rep(i,<span class="number">0</span>,n) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,a+i,b+i);</span><br><span class="line">		ll s=<span class="number">0</span>,d=<span class="number">1l</span>l&lt;&lt;<span class="number">60</span>;;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			extra[i]=<span class="built_in">max</span>(<span class="number">0l</span>l,a[i]-b[(i+n<span class="number">-1</span>)%n]);</span><br><span class="line"> <span class="comment">//这里计算在总生命值量和总爆炸伤害量已知的情况下，杀死一个怪物的代价</span></span><br><span class="line">			s+=extra[i];</span><br><span class="line">		<span class="comment">//	printf("%d %lld\n",i,extra[i]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		rep(i,<span class="number">0</span>,n) d=<span class="built_in">min</span>(d,s-extra[i]+a[i]);</span><br><span class="line"><span class="comment">//找到杀死一头怪物所要付出的最小代价</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反思：刚开始我想岔是因为没有考虑到整体，而是盲目的从局部性价比最优的方式来计算，实际上从整体生命值和总体爆炸伤害值来看，如果我们选择不同的突破口，那么有一部分代价是完全逃避不了的，因为你如果不动它，那么上一个怪物的伤害值是无论如何都不可能杀死他的，我们只能做到第一步就找到代价最小的方式来减少损失</p>
<h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：有n个点，从1到 n ,再从 n 到1，任意两点之间都存在两条有向边，要求找到从1到n再回到n,经过且不重复经过每一条边，最小的字典序方案，给出字典序方案中从 l 位到 r 位的序列号</p>
<p>这道题为贪心和图论的结合，想到解决方法并不难，但是想要用代码实现感觉让人头大,感觉没有特定的板子啊，这是我看到的解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&gt;s[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> a=lower_bound(s+<span class="number">1</span>,s+n,x)-s;</span><br><span class="line">	<span class="keyword">int</span> b=x-s[a<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span> (b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b/<span class="number">2</span>+a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%lld%lld"</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">		rep(i,<span class="number">1</span>,n+<span class="number">1</span>) s[i]=s[i<span class="number">-1</span>]+<span class="number">2</span>*(n-i);</span><br><span class="line">		<span class="keyword">for</span> (ll i=l;i&lt;=r;i++)</span><br><span class="line">		 	<span class="built_in">printf</span>(<span class="string">"%d "</span>,calc(i));</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);<span class="comment">//换行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing 记录 第一章</title>
    <url>/2020/04/20/acwing-%E8%AE%B0%E5%BD%95%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<p>这里是acwing上面dp专题的价值题的收集，算是dp专题吧</p>
<a id="more"></a>

<h2 id="275-传纸条"><a href="#275-传纸条" class="headerlink" title="275.传纸条"></a>275.传纸条</h2><h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/solution/acwing/content/2851/" target="_blank" rel="noopener">https://www.acwing.com/solution/acwing/content/2851/</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题是一道线性dp，求出不重合的两条路线的权值之和，我们可以设想为两个人在互不重合的路线上同时出发同时到达，设他们所处的坐标横纵之和为m+n，第一位的横坐标为i,第二位为j,对应的纵坐标就是m+n-i,m+n-j，由此我们可以确定状态f[k] [i] [j]，即坐标值和为k的时候两个人的权值之和的最大值，那么能够走到这一步有四种可能，分别为右右，右下，下右，下下，并且我们注意到，如果i==j,那么说明此时两个人的走到了同一位置，此时由于此种情况不可能存在，我们之间舍去即可</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>暴力枚举加部分贪心，通过枚举左端的人的位置，由于右端的人不可能再从更左的地方出发（可能出发的情况早已经储存在了之前的状态之中），那么我们可得到四重循环的结果f[n-1] [m] [n-1] [m]，这样子有一个好处，可以避免对两人坐标相同时的讨论，但是复杂度仍然很高，无论是空间还是时间都是O(n^4)</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">55</span>][<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">// (i,j) 是第一条路径坐标 (k,l) 是第二条</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=j+<span class="number">1</span>;l&lt;=m;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> w1=f[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],w2=f[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l];</span><br><span class="line">                    <span class="keyword">int</span> w3=f[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],w4=f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l];</span><br><span class="line">                    f[i][j][k][l]=<span class="built_in">max</span>(w1,<span class="built_in">max</span>(w2,<span class="built_in">max</span>(w3,w4)))+v[i][j]+v[k][l];</span><br><span class="line">                    <span class="comment">//我们用贪心思想可得两条路径肯定不相交 (能取数就取数)</span></span><br><span class="line">                    <span class="comment">//那么令 l=(j+1,m) 即满足了此条件 (保证了第二条路线一定在第一条路线下面) </span></span><br><span class="line">                    <span class="comment">//不用判重因为不会重两条路径不相交 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][m<span class="number">-1</span>][n<span class="number">-1</span>][m]); </span><br><span class="line">    <span class="comment">//dp 是达不到 (n,m) 的,但 (n,m) 等价于 (n-1,m),(n,m-1) (因为 v(n,m)==0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>就是设定总计的步数为k,两人坐标分别为(i,k-i) (j,k-j)</p>
<p>从而得到状态f[k] [i] [j]</p>
<p>当i != j时，此时两者处在不同的位置，那么就可以通过四种达到该状态的方式来得出f[k] [i] [j]的值，如果i==j，直接不做讨论，跳过完事，除非时i==j==0||n的情况</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N * <span class="number">2</span>][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n + m; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, k - m); i &lt;<span class="built_in">min</span>(n+<span class="number">1</span>,k); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>, k - m); j &lt;<span class="built_in">min</span>(n+<span class="number">1</span>,k); j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b ++ )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> t = g[i][k - i];</span><br><span class="line">                        <span class="keyword">if</span> (i != j || k == <span class="number">2</span> || k == n + m)</span><br><span class="line">                        &#123;</span><br><span class="line">                            t += g[j][k - j];</span><br><span class="line">                            f[k][i][j] = <span class="built_in">max</span>(f[k][i][j], f[k - <span class="number">1</span>][i - a][j - b] + t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n + m][n][n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法一规避了对两者位置相同的时的判断，代码简化且方式粗暴，但是由于没有对步长的限制，导致了对时间和空间上的极大浪费，第二种方式通过对步长的限制，使得计算降低了一个维度</p>
<h2 id="1014-登山"><a href="#1014-登山" class="headerlink" title="1014.登山"></a>1014.登山</h2><h3 id="链接：-1"><a href="#链接：-1" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1016/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/1016/</a></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这是一道经典的LIS题目，但是我们可以用双dp数组的思想来做，降低代码复杂度</p>
<p>方法：设置两个数组dp_high,dp_sum，前者dp_high[i]表示序列为i的元素结尾的序列的最长上升子序列长度，后者dp_sum[i]表示以i结尾的序列的最长先上升在下降序列长度</p>
<p>有状态转移方程：对任意j&lt;i</p>
<p>if(a[j]&lt;a[i]) dp_high[i]=max(dp_high[i],dp_high[j]+1)</p>
<p>else if(a[j]&gt;a[i]) </p>
<p>dp_sum[i]=max(dp_sum[i],max(dp_sum[j]+1,dp_high[j]+1))</p>
<p>时间复杂度没有明显降低，但是提供了一种嵌套迭代的思想</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line"></span><br><span class="line">    dp_inc[i] = <span class="number">1</span>, dp_dec[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[j] &lt; h[i])</span><br><span class="line">            dp_inc[i] = <span class="built_in">max</span>(dp_inc[i], dp_inc[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(h[j] &gt; h[i])</span><br><span class="line">            dp_dec[i] = <span class="built_in">max</span>(dp_dec[i], <span class="built_in">max</span>(dp_inc[j]+<span class="number">1</span>, dp_dec[j]+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(dp_inc[i], dp_dec[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1011-登山"><a href="#1011-登山" class="headerlink" title="1011.登山"></a>1011.登山</h2><h3 id="链接：-2"><a href="#链接：-2" class="headerlink" title="链接："></a>链接：</h3><p><a href="https://www.acwing.com/problem/content/1012/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/1012/</a></p>
<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>求最大上升子序列和最长不降子序列的长度，可以使用lower_bound和upper_bound两个函数，两者正常情况下的都是对升序列使用，如果需对降序列使用必须使用greater<type>()或者重载模型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对降序序列使用</span><br><span class="line">    lower_bound(f,f+n,a,greater&lt;<span class="keyword">int</span>&gt;())求出第一个小于或等于a的f[n]的位置，没有返回<span class="built_in">end</span>;</span><br><span class="line">	upper_bound返回的是不能等于的数</span><br><span class="line">对结构体使用</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.value1 != b.value1) <span class="keyword">return</span> a.value1 &lt; b.value1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.value2 &lt; b.value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span>  f[N],a,g[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos1,pos2,cnt,len;</span><br><span class="line">	len=cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a) &#123;</span><br><span class="line">		pos1=upper_bound(f,f+len,a,greater&lt;<span class="keyword">int</span>&gt;())-f;</span><br><span class="line">		<span class="keyword">if</span>(pos1==len) f[len++]=a;</span><br><span class="line">		<span class="keyword">else</span> f[pos1]=a;</span><br><span class="line"> 		<span class="comment">//为什么包含等于非严格递增或递减的时候我们反而要用upper呢，这是因为这样子才能做到只有更小的节点才能更新len的长度</span></span><br><span class="line">		pos2=lower_bound(g,g+cnt,a)-g;</span><br><span class="line">		<span class="keyword">if</span>(pos2==cnt) g[cnt++]=a;</span><br><span class="line">		<span class="keyword">else</span> g[pos2]=a;</span><br><span class="line">        <span class="comment">//这里是严格递增的，所以用lower_bound</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="187-导弹防御系统"><a href="#187-导弹防御系统" class="headerlink" title="187.导弹防御系统"></a>187.导弹防御系统</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这是一道df题目，虽然披着LIS的皮，对于每一个点，我们都有两种选择：放到上升子序列集合或者下降子序列集合之中</p>
<p><a href="https://www.acwing.com/solution/AcWing/content/4010/" target="_blank" rel="noopener">这个分析的太好了</a></p>
<p>注意事项：</p>
<ol>
<li>可以使用<code>while(!dfs(depth,0,0,0))depth++</code>,这里的代码使用的是当dfs首次满足条件t==n（所有的点全部都集合之中）且集合数之和小于总数之和时对应的集合数之和的最小值，同样可以满足要求</li>
<li>必须要回溯，<code>temp=h[i](d[i])...h[i](d[i])=temp</code>否则会对之后的结果造成影响</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> d, <span class="keyword">int</span> t)</span>  <span class="comment">//u表示上升的系统个数，d表示下降的系统个数,t表示第t个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u + d &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(t ==  n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u + d &lt; ans)ans = u + d;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= u; i++)  <span class="comment">//找到第一个末尾数小于a[t]的导弹系统</span></span><br><span class="line">        <span class="keyword">if</span>(up[i] &lt; a[t])<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = up[i];</span><br><span class="line">    up[i] = a[t];<span class="comment">//添加到该导弹系统中</span></span><br><span class="line">    dfs(<span class="built_in">max</span>(u, i), d, t + <span class="number">1</span>);</span><br><span class="line">    up[i] = temp;  <span class="comment">//恢复现场</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++)<span class="comment">//找到第一个末尾数大于a[t]的导弹系统</span></span><br><span class="line">        <span class="keyword">if</span>(down[i] &gt; a[t])<span class="keyword">break</span>;</span><br><span class="line">    temp = down[i];</span><br><span class="line">    down[i] = a[t];<span class="comment">//添加到该导弹系统中去</span></span><br><span class="line">    dfs(u, <span class="built_in">max</span>(d, i), t + <span class="number">1</span>);</span><br><span class="line">    down[i] = temp;<span class="comment">//恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        ans = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="272-最大公共子序列"><a href="#272-最大公共子序列" class="headerlink" title="272.最大公共子序列"></a>272.最大公共子序列</h2><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.acwing.com/problem/content/274/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/274/</a></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>状态分析：</p>
<p>对于Ai,Bj,有</p>
<p>当Ai != Bj时，有f[i,j]==f[i-1,j];</p>
<p>当Ai == Bj时，有F[i,j]=max(0&lt;=k&lt;j,Bk&lt;Bj){f[i-1,k]}+1</p>
<p>可以使用三重循环来得到解，但其实应该有优化，我们思考k，实际上每一次当第二层移动时，a[i]是不动的，对于b[j]，如果它小于当前a[i],那么他的上一层a[i-1] [j]就有可能变成a[i] [j]的父节点，我们用maxv将当前a[i] [j]对应的最大的a[i-1] [k]用一个数字存起来就行了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> maxv=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[j])	f[i][j]=maxv+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> f[i][j]=f[i][j];</span><br><span class="line">    	<span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            maxv=maxv(maxv,f[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>acwing</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 633 div.2&amp;&amp; round 634 div.3回顾</title>
    <url>/2020/04/15/codeforces-round-633-div-2-round-634-div-3%20round%20635%20div.2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>codeforces上的比赛一直都很多，索性一次性将有价值的题目全部都放到一起来写了</p>
<a id="more"></a>

<h2 id="round-633"><a href="#round-633" class="headerlink" title="round 633"></a>round 633</h2><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>题意：给定指定的n个点，n-1条无向路（也就是说没有成环的可能），可以给路径随机分配正权值，从一个叶节点走到另外的叶节点路途中，所途径权值异或之和应该为零，问权值数量最少为多少，最多为多少</p>
<p>分析：首先我们先判断最小值的情况，我们可以发现，如果存在有两个节点之间的边数为奇数，那么权值的种类最小数必定为三，然后再去判断最大值的情况，两个或者两个以上叶节点同时连在了一个点上的情况中，这几个叶结点的权值边应该全部相同，所以只需要保留一个就可以了，把删掉的节点数用一个数字存起来，最大值就是 n-1-该数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,ans=<span class="number">0</span>,fl=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100005</span>],one;</span><br><span class="line"><span class="keyword">int</span> qi=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y!=<span class="number">-1</span>&amp;&amp;v[x].<span class="built_in">size</span>()==<span class="number">1</span>)&#123;	<span class="comment">//从所有的叶节点出发，到其他的的叶节点，判断路径的奇偶</span></span><br><span class="line">        <span class="keyword">if</span>(z%<span class="number">2</span>) ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">0</span>,v[x].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x][i]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v[x][i],x,z+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> minn=<span class="number">0</span>,maxn=n<span class="number">-1</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        v[a].push_back(b);</span><br><span class="line">        v[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i].<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;qi==<span class="number">0</span>)&#123;</span><br><span class="line">            qi=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        rep(j,<span class="number">0</span>,v[i].<span class="built_in">size</span>()<span class="number">-1</span>)&#123;			<span class="comment">//删除多余叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(v[v[i][j]].<span class="built_in">size</span>()==<span class="number">1</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>) fl+=cnt<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(qi,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>) minn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minn=<span class="number">3</span>;</span><br><span class="line">    maxn-=fl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minn,maxn);</span><br></pre></td></tr></table></figure>

<h2 id="round-634"><a href="#round-634" class="headerlink" title="round 634"></a>round 634</h2><h3 id="E1题"><a href="#E1题" class="headerlink" title="E1题"></a>E1题</h3><p>题意：给定一个数组，问在不改变顺序的情况下，通过删减数组中元素，使得数组变成’ABA’型回文串是否可能，如果可能，请输出最大的回文串的长度</p>
<p>分析：dp题，用数组从左往右遍历，用a[i] [j]表示当前位置 j 情况下字符 i 的数量，然后再用从每一个位置开始，</p>
<p>以当前位置为左端，设置右端，再遍历26个字母的存在，使得</p>
<p>maxin=max(maxin,a[i] [r+1]-a[i] [l]);</p>
<p>maxout=max(maxout,min(a[i] [l],a[i] [n]-a[i] [r+1])*2);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(a) int((a).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; int(n); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fore(i, l, r) for (int i = int(l); i &lt; int(r); ++i)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : a) <span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">		forn(i, n) &#123;</span><br><span class="line">			forn(j, <span class="number">26</span>) cnt[j][i + <span class="number">1</span>] = cnt[j][i];</span><br><span class="line">			++cnt[a[i] - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		forn(i, <span class="number">26</span>) ans = <span class="built_in">max</span>(ans, cnt[i][n - <span class="number">1</span>]);</span><br><span class="line">		forn(l, n) fore(r, l, n) &#123;</span><br><span class="line">			<span class="keyword">int</span> cntin = <span class="number">0</span>, cntout = <span class="number">0</span>;</span><br><span class="line">			forn(el, <span class="number">26</span>) &#123;</span><br><span class="line">				cntin = <span class="built_in">max</span>(cntin, cnt[el][r + <span class="number">1</span>] - cnt[el][l]);</span><br><span class="line">				cntout = <span class="built_in">max</span>(cntout, <span class="built_in">min</span>(cnt[el][l], cnt[el][n] - cnt[el][r + <span class="number">1</span>]) * <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, cntin + cntout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构 KMP模式匹配</title>
    <url>/2020/04/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>KMP匹配是判断两个线性表之间是否存在子母串关系的算法，并且能够定位到子串所处的位置</p>
<a id="more"></a>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1 .首先对小的字符串A进行自我”匹配”，设置next数组，其中next[i]表示“A中以a[i]结尾的非前缀子串”与”A的前缀”所能匹配到的最大长度</p>
<p>公式： next[i]=max{j},其中j&lt;i并且A[i-j+1 ~ i]==A[1 ~ j]</p>
<p>特别的：当不存在这样的 j 时，令next[i]=0</p>
<p>2 .对字符串A和B进行匹配，求出一个数组f，其中f[i]表示“B中以i结尾的字串”与”A的前缀”能够匹配到的最大长度</p>
<p>公式： f[i]=max{j},其中j&lt;i并且B[i-j+1 ~i]==A[1 ~ j]</p>
<p>当j的长度超过了n时，应该把j=next[j];</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于j&lt;i,则j是next[i]的一个候选项，则小于j的next[i]的最大候选项是next[j],这是一个套娃的关系，直到满足条件或者next[j]==0</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next数组的求法</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=a[j+<span class="number">1</span>]) j=next[j];</span><br><span class="line">    <span class="comment">//找到符合条件的j,或者j==0;</span></span><br><span class="line">    <span class="keyword">if</span>(a[i]==a[j+<span class="number">1</span>]) j++; </span><br><span class="line">    <span class="comment">//如果符合条件，加上末尾的元素</span></span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f数组的求法（大同小异）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;(j==n||b[i]!=a[j+<span class="number">1</span>])) j=next[j];</span><br><span class="line">    <span class="keyword">if</span>(b[i]==a[j+<span class="number">1</span>]) j++;</span><br><span class="line">	f[i]=j;</span><br><span class="line">    <span class="comment">//当f[i]==n的时候，说明子串就出现了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ1961</a></p>
<p>题意：求循环元，首先我们设s[1~i]拥有长度为len的循环元</p>
<p>那么len必定满足以下条件：</p>
<p>len|i &amp;&amp; s[len+1<del>i]==s[1</del>i-len]</p>
<p>而最小循环节则满足</p>
<p>s[len] (最小循环节)=next[i]</p>
<p>综上，得到代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[j+<span class="number">1</span>]!=a[i]) j=next[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i]) j++;</span><br><span class="line">        next[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">        calc_next();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test case"</span>&lt;&lt;++T&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>&amp;&amp;i/(i-next[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;i/(i-next[i])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 636 div.2回顾</title>
    <url>/2020/04/22/codeforces-round-636-div-2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>昨晚的比赛感觉更像是div.2了。。。分类有点古怪</p>
<a id="more"></a>

<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p>重要代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m%sum)&#123;</span><br><span class="line">	k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    sum+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>一道dp题目，但是更加直观的可能是模拟，列出四种情况，判断进行的操作，代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : a) <span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur = a[i];</span><br><span class="line">			<span class="keyword">int</span> j = i;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; sgn(a[i]) == sgn(a[j])) &#123;</span><br><span class="line">				cur = <span class="built_in">max</span>(cur, a[j]);</span><br><span class="line">				++j;</span><br><span class="line">			&#125;</span><br><span class="line">			sum += cur;</span><br><span class="line">			i = j - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>这道题乍看起来不是很好操作，可以操作的点实在是太多了，但是我们可以观察到，对于一对数字a[i]和a[n-i+1]来说，最终的改变情况可能有四种(2^2)，综合来看我们可以得到最终总和的变化范围是</p>
<p>2-min(a[i],a[n-i+1])+1-a[i]+a[n-i+1]-max(a[i],a[n-i+1])+k-k*2(此处默认理想范围，不理想也没关系)</p>
<p>这里为什么是范围呢，因为我们并不能知道其他的元素能将这对数字变成具体的某个数字，只能确定的那个大概的范围，我们可以知道，如果出在了第一个阶段和第三个阶段，那么改变了两个数字，如果是处在第二阶段中，那么就是改变了一个数字，我们只要在2~k中处理前缀和，得到最终结果就可以了</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt[<span class="number">1</span>]+=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//初始化为2，此时是最低值2的前缀，默认改变两次</span></span><br><span class="line">			cnt[<span class="built_in">min</span>(a[i],a[n-i+<span class="number">1</span>])+<span class="number">1</span>]--;</span><br><span class="line">            <span class="comment">//当遇到低值至最高的范围中时没必要再改变两个，改变不在边上的就好了</span></span><br><span class="line">			cnt[<span class="built_in">max</span>(a[i],a[n-i+<span class="number">1</span>])+k+<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">//超出最大最小值能够够得着的范围，只能两个都改变</span></span><br><span class="line">			cnt[a[i]+a[n-i+<span class="number">1</span>]]--;</span><br><span class="line">            <span class="comment">//特判，当遇到不需要改变值的情况</span></span><br><span class="line">			cnt[a[i]+a[n-i+<span class="number">1</span>]+<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">//结束特判</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k*<span class="number">2</span>;i++)</span><br><span class="line">        <span class="comment">//遍历，寻找k值，得到最小的ans</span></span><br><span class="line">		&#123;</span><br><span class="line">			cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,cnt[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h3><p>题意：无向图一张，求a到b到c最短需要多久，这个是已经给出了图，要我们找到最短路之后给他们设置给定的一组边长中的值，使得最短路仍然是最短路</p>
<p>分析：最短路，最短路，又是这玩意，看似好做，实则麻烦死。首先我们必须得到边权值全部为1时的最短路，再来给边路分配权值，对于由a-b-c这样的路径，对于图中的所有点n，都存在有路线先从a到n,再从n到b最后到c的情况，我们所要求的最小路径中最小权值必定优先满足n到b的路径，因为要经过其两次，也不是绝对的，比如当n到b的路径太长导致超过了其余的</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> nxt;</span><br><span class="line">&#125;e[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">int</span> t,n,m,a,b,c,edgenum,head[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">3</span>][<span class="number">200005</span>];</span><br><span class="line">ll p[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//头插法的链接表（就是链表）</span></span><br><span class="line">	e[++edgenum].to=v;</span><br><span class="line">	e[edgenum].nxt=head[u];</span><br><span class="line">	head[u]=edgenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span>*dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.push(st);</span><br><span class="line">	dis[st]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> node=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> hd=head[node];hd;hd=e[hd].nxt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> to=e[hd].to;</span><br><span class="line">			<span class="keyword">if</span>(!dis[to])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[to]=dis[node]+<span class="number">1</span>;</span><br><span class="line">				q.push(to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)head[i]=dis[<span class="number">0</span>][i]=dis[<span class="number">1</span>][i]=dis[<span class="number">2</span>][i]=<span class="number">0</span>;</span><br><span class="line">		edgenum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line">		sort(p+<span class="number">1</span>,p+m+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i]+=p[i<span class="number">-1</span>];</span><br><span class="line">           	<span class="comment">//这里存好长度为i的路径对应的最小值</span></span><br><span class="line">			<span class="keyword">int</span> u,v;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">			add(u,v);</span><br><span class="line">			add(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(a,dis[<span class="number">0</span>]);</span><br><span class="line">		bfs(b,dis[<span class="number">1</span>]);</span><br><span class="line">		bfs(c,dis[<span class="number">2</span>]);</span><br><span class="line">		ll ans=<span class="number">1e18</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[<span class="number">0</span>][i]+dis[<span class="number">1</span>][i]+dis[<span class="number">2</span>][i]<span class="number">-3</span>&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//这个点，应该就是规避n到b的路径过长的问题吧，但是感觉没后面的好使</span></span><br><span class="line">			ans=<span class="built_in">min</span>(ans,p[dis[<span class="number">1</span>][i]<span class="number">-1</span>]+p[dis[<span class="number">0</span>][i]<span class="number">-1</span>+dis[<span class="number">1</span>][i]<span class="number">-1</span>+dis[<span class="number">2</span>][i]<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">//配合p[i]对应的最小值，起飞</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 632 Div.2回顾</title>
    <url>/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ</p>
<a id="more"></a>

<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p> <a href="https://codeforces.com/contest/1333" target="_blank" rel="noopener">https://codeforces.com/contest/1333</a></p>
<h2 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h2><p>一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'W'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">'B'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h2><p>给定上下两个序列，上面一个序列可以进行一种运算:</p>
<p>对任意i &lt; j ,可以使得aj = ai+aj </p>
<p>要求是能否通过这种运算使得上面的数列等于下面的，其实就是找上面数列的1和-1的位置，再和每一位进行比对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod9 998244353</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,m,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,b[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vis[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">                <span class="keyword">if</span>(b[i]&gt;a[i]&amp;&amp;vis[<span class="number">0</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[i]&lt;a[i]&amp;&amp;vis[<span class="number">1</span>]==<span class="number">0</span>) flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">1</span>) vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==<span class="number">-1</span>) vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h2><p>题意给定一个序列，只能从左端或者右端截取一段走形成新的子序列，不存在可以从中间直接拿取（我就理解错了），所以这样子算来实际的序列数量是1+2+…..n，即 (n+1)*n/2 ,只要子序列中任意一个存在和为零的情况，那么这个序列就不符合要求，结果求得是符合要求的序列的数量，刚开始我还以为是一个求子序列和的问题，没有特别多的思路就选择做了后面的题目，毕竟2^n难以处理，结果因为传达了错误的题意还坑了和自己的一起写的大佬（捂脸）</p>
<p>处理：由于其子序列取得方式，我们可以推理，假设一个序列和为零，那么其右端所有序列（即母序列）也不符合要求，进一步想，我们会发现，假设从左往右计数求和sum，如果sum的值出现了两次，那么说明中间一段必定为和为零的序列，所以可以使用map<int int >记录下每个sum出现的最新位置，如果出现了重复的sum,就对其右边的母序列进行清除。不用注意重复子序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>,n,sum=<span class="number">0</span>,cnt=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成1，避免首元素就是0的情况</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.count(sum))&#123;</span><br><span class="line">        	cnt=<span class="built_in">max</span>(cnt,mp[sum]);</span><br><span class="line">		&#125;</span><br><span class="line">        ans+=i-cnt;</span><br><span class="line">        mp[sum]=i+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里设置成i+1,剪掉0子序列的首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h2><p>将序列当中全部向左转的跳到左边，右转的调到右边，这里看到了一位学长的代码，非常熟练地使用了各种STL，我从中学到了很多新的东西，比如范围for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;type&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> n:k)	<span class="built_in">cout</span>&lt;&lt;n;</span><br></pre></td></tr></table></figure>

<p>题解如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j,k,t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        p.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'R'</span>&amp;&amp;a[i+<span class="number">1</span>]==<span class="string">'L'</span>) </span><br><span class="line">                p.push_back(i++),swap(a[i],a[i<span class="number">-1</span>]),</span><br><span class="line">            	flag=<span class="literal">false</span>,sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        q.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k||sum&lt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d:q)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,d.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:d) <span class="built_in">printf</span>(<span class="string">" %d"</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>如何储存路径元素</title>
    <url>/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>图的路径追溯一直都是个比较麻烦的问题，这里写一下看到的储存方法</p>
<a id="more"></a>

<h2 id="最短路路径"><a href="#最短路路径" class="headerlink" title="最短路路径"></a>最短路路径</h2><p>题目链接：<a href="http://poj.org/problem?id=1734" target="_blank" rel="noopener">POJ1734</a></p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图使用floyd，最小环长度应该是：</p>
<p>min( 1&lt;= i&lt; j &lt; k) {d[i,j] + a[i,k] + a[k,j]}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],d[N][N],pos[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pos[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    get_path(x,pos[x][y]);</span><br><span class="line">    path,push_back(pos[x][y]);</span><br><span class="line">    get_path(pos[x][y],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[y][x]=a[x][y]=<span class="built_in">min</span>(a[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(d,a,<span class="keyword">sizeof</span> a);	<span class="comment">//这波很骚；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;ik&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ki++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]+a[i][k]+a[k][j]&lt;ans)&#123;</span><br><span class="line">                    ans=d[i][j]+a[i][k]+a[k][j];</span><br><span class="line">                    path.<span class="built_in">clear</span>();</span><br><span class="line">                    path.push_back(i);</span><br><span class="line">                    get_path(i,j);</span><br><span class="line">                    path.push_back(j);</span><br><span class="line">                    path.push_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]&gt;d[i][k]+d[k][j])&#123;</span><br><span class="line">                    d[i][j]=d[i][k]+d[k][j];</span><br><span class="line">                    pos[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用了pos[i] [j]这个矩阵存储了两个点之间的中间路径，同时get_back函数通过递归调用再次得出i与k,k与j之间的关系，但是注意，这个方法只能存储最短路的路径，不能存储所有的路径。。。</p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图使用二分堆优化的dijkstra,同样是使用pos存储中间节点，方法：枚举1-n之间的起点s,从s开始出堆，但是s出堆之后立刻将d[s]设置为无穷大，这样子s第二次入堆时得到的就是最小有向环</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>同余</title>
    <url>/2020/04/13/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<p>最近一次的周赛中暴露了同余逆元的短板，连板子都不会用，哎，只能加紧补了</p>
<a id="more"></a>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果a,b对正整数n的余数相等，那么a≡b(mod n)</p>
<h3 id="同余类和剩余类"><a href="#同余类和剩余类" class="headerlink" title="同余类和剩余类"></a>同余类和剩余类</h3><p>对于所有a∈ [0,m-1], 集合 {a+km}对于m同余，该集合称为一个m的同类余，一个模m的同类余一共有{0,1,…..m-1}共m个，被称为完全剩余系</p>
<p>完全剩余系中与m互质的同类余有φ(m)个，被称为m的简化剩余系，简化剩余系的积也是m的简化剩余系</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若p是质数，则对于任意正整数a，有a^p≡a(mod p)</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若正整数 a,n互质，那么a^φ(n)≡1(mod n),其中φ(n)是欧拉函数(不超过n的简化剩余系元素)</p>
<p>推论：</p>
<p>若正整数a ,n互质,对于任意正整数b，</p>
<p>有:  a^b≡a^(b mod φ(n)) (mod n)</p>
<p>这些定理的证明链接：<a href="https://www.cnblogs.com/zylAK/p/9569668.html" target="_blank" rel="noopener">https://www.cnblogs.com/zylAK/p/9569668.html</a></p>
<p>快速幂取余的板子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mod</span><span class="params">(LL a,LL b,LL mod)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="comment">//b==1</span></span><br><span class="line">            ans=ans*a%mod；</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别情况：当a，n不一定互质的且b&gt;φ(n)情况下，可以有：</p>
<p>a^b≡a^(b modφ(n)+φ(n)) (mod n)</p>
<p>例题：<a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">POJ3696</a></p>
<p>最近发现欧拉定理的拓展不能用在快速幂板子，会导致答案错误，是一把双刃剑</p>
<h3 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h3><p>某打不出名字的定理：</p>
<p>对于任意整数a,b,存在一对整数x,y,满足 ax+by == gcd(a,b)</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123; x=<span class="number">1</span>,y=<span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> z=x; x=y; y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>若整数 b,m互质，并且 b|a，则存在一个整数x，使得a/b≡a*x(mod m),则x称为b的模m乘法逆元，记为b ^-1(mod m)</p>
<p>当模数m为质数时，b^m-2即为b的乘法逆元</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）bellman-ford和SPFA</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/</url>
    <content><![CDATA[<p>bellman-ford流程：</p>
<ol>
<li>扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y]</li>
</ol>
<p>重复以上步骤，直到没有更新步骤发生</p>
<p>复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra</p>
<a id="more"></a>

<p>SPFA:</p>
<ol>
<li><p>建立一个队列，最初队列中只有起点1</p>
</li>
<li><p>取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队</p>
</li>
<li><p>重复上面步骤，直到队列为空</p>
</li>
</ol>
<p>这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>(<span class="keyword">int</span>) q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>,v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],x=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!v[x])	q.push(y),v[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SPFA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是该方法对于边权存在为负数的边同样适用。</p>
<p>并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）单源最短路径-dijkstra</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/</url>
    <content><![CDATA[<p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p>
<a id="more"></a>

<ol>
<li>初始化d[1]=0,然后将其余的 distance 全部设置为最大</li>
<li>进行n-1次循环，每次都找最小了distance[x],将x标记</li>
<li>扫描该x的全部出边（x,y,z）,if d[y]&gt;d[x]+z),更新d[y] </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[j]&amp;&amp;(x==<span class="number">0</span>||d[j]&lt;d[x]))	x=j;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		a[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="string">"x"</span>)&#123;</span><br><span class="line">				a[i][j]=a[j][i]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">					n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a[i][j]=a[j][i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		d[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	search();</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，主要复杂度来自第一步对全局最小值的寻找，适用于求单源路径.</p>
<p>下面是使用二叉树堆对dist进行维护之后，可以在O(mlogn)的时间内实现dijkstra:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],ver[M],edge[M],next[M],d[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//注意这里的key值是dist值的相反数，因为要选取最小值，第二个值为对应的节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.top().second,q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],i;i=next[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> y=ver[i],z=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;d[x]+z)&#123;</span><br><span class="line">                d[y]=d[x]+z;</span><br><span class="line">                q.push(make_pair(-d[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）两点间无向最短路径 floyd</title>
    <url>/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/</url>
    <content><![CDATA[<p>floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化</p>
<p>如果想要了解内部缘由不妨移步：<a href="https://www.zhihu.com/question/30955032/answer/68834307" target="_blank" rel="noopener">为什么k要放在最外层</a></p>
<a id="more"></a>

<p>设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。</p>
<p>得到公式：</p>
<p>D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j])</p>
<p>可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;				<span class="comment">//floyd的状态转移方程：d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]),可以转换成三重循环的。。 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		<span class="comment">//最外层循环是为了找到能不能有其他点帮助目标点完成最短路。。。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">                d[a[i]][a[j]]=d[a[j]][a[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum+=d[i][j];</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans*<span class="number">100</span>/(n<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递闭包：传递推导尽量多的元素之间的关系(感觉并查集也能解决相等的关系，但是大于小于不行)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j]|=d[i][k]&amp;d[k][j];</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）邻接矩阵和邻接表</title>
    <url>/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<p>对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。</p>
<a id="more"></a>

<ol>
<li><p>邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。</p>
</li>
<li><p>邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。</p>
<p>插入和遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入有向边(x,y,z)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	ver[++tot]=y,edge[tot]=z;</span><br><span class="line">    next[tot]=head[x],head[x]=tot;</span><br><span class="line">    <span class="comment">//注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有x出发的有向边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=next[i])&#123;	</span><br><span class="line">    <span class="comment">//这里面的i如果为0.结束循环</span></span><br><span class="line">	<span class="keyword">int</span> y=ver[i],x=ver[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈问题：寻找最大矩形面积</title>
    <url>/2020/04/12/%E5%8D%95%E8%B0%83%E5%A0%86%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 单调堆和队列可以对分析进行优化</p>
<a id="more"></a>

<h2 id="单调堆："><a href="#单调堆：" class="headerlink" title="单调堆："></a>单调堆：</h2><p>链接：<a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ2559</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[n+<span class="number">1</span>]=p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;s[p])</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">width</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[p]&gt;a[i])&#123;		</span><br><span class="line">			<span class="built_in">width</span>+=w[p];</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">width</span>*s[p]);</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++p]=a[i],w[p]=<span class="built_in">width</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最大子序和：给定一个长为N的整数序列，求找到一段不超过M的连续子序列，使得子序列中的所有数的和为最大值。N,M&lt;+3*10^5</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们思考一下，对于任意一个点i,以它结尾的子序列的的首位j一定存在如下情况：在不超过i的前置位M的情况下，s[j]一定是最小的，直到i右移，有新的单元s[i]加入能够替换s[j]或者超过最大限度M不得不换更右边的数字.</p>
<p>这里我们得用到单调递减序列，最优选择的序列集合一定是“下标位置递增，对应的前缀和的值也递增的”序列。我们这里使用一个一队列来保存这个序列。</p>
<p>操作如下：</p>
<ol>
<li>判断队头决策与i的距离是否超出M的范围，若超出则出队</li>
<li>此时对头就是右端点为i时，左端点的最优选择</li>
<li>不断删除队尾决策，直到队尾对应的S值小于等于s[i] 。然后把i作为一个新决策入队</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">//初始化在首位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-m)	l++;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,sum[i]-sum[q[l]]);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r&amp;&amp;sum[q[r]]&gt;=sum[i])	r--;</span><br><span class="line">    <span class="comment">//如果s[i]最小，相当于清空了队列。。</span></span><br><span class="line">    q[++r]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>（图论初学）单源最短路径：dijkstra</title>
    <url>/2020/04/04/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra/</url>
    <content><![CDATA[<p>目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。</p>
<a id="more"></a>

<ol>
<li>初始化d[1]=0,然后将其余的dist全部设置为最大</li>
<li>进行n-1次循环，每次都找最小了dist[x],将x标记</li>
<li>扫描该x的全部出边（x,y,z）,ifd[y]&gt;d[x]+z),更新d[y] </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],a[maxn][maxn],v[maxn],ans,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[j]&amp;&amp;(x==<span class="number">0</span>||d[j]&lt;d[x]))	x=j;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[x]+a[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		a[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">			<span class="keyword">if</span>(s==<span class="string">"x"</span>)&#123;</span><br><span class="line">				a[i][j]=a[j][i]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">					n=n*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a[i][j]=a[j][i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		d[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	search();</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(d[i],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)…适用于求单源路径…<br>最优序列方法，之后更新…</p>
<p>categrories: </p>
<ul>
<li>ACM</li>
</ul>
]]></content>
  </entry>
</search>
