{"meta":{"title":"收集瓶","subtitle":"虽说人类一思考,上帝就发笑,但是人类不思考,上帝连发笑都不屑","description":"HUT/ACMer","author":"softmountain","url":"http://yoursite.com","root":"/"},"posts":[{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"连通分量","date":"2020/07/22","text":"图论暑假学习的第一天:) 今天的内容是连通分量和前面的LCA 有向图连通分量受欢迎的牛123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010, M = 50010;int n, m;int h[N], e[M], ne[M], idx;int dfn[N], low[N], timestamp;int stk[N], top;bool in_stk[N];int id[N], scc_cnt, Size[N];int dout[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u, in_stk[u] = true; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!dfn[j]) &#123; tarjan(j); low[u] = min(low[u], low[j]); &#125; else if (in_stk[j]) low[u] = min(low[u], dfn[j]); &#125; if (dfn[u] == low[u]) &#123; ++ scc_cnt; int y; do &#123; y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; Size[scc_cnt] ++ ; &#125; while (y != u); &#125;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); &#125; for (int i = 1; i &lt;= n; i ++ ) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i ++ ) for (int j = h[i]; ~j; j = ne[j]) &#123; int k = e[j]; int a = id[i], b = id[k]; if (a != b) dout[a] ++ ; &#125; int zeros = 0, sum = 0; for (int i = 1; i &lt;= scc_cnt; i ++ ) if (!dout[i]) &#123; zeros ++ ; sum += Size[i]; if (zeros &gt; 1) &#123; sum = 0; break; &#125; &#125; printf(\"%d\\n\", sum); return 0;&#125; 学校网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110, M = 10010;int n;int h[N], e[M], ne[M], idx;int dfn[N], low[N], timestamp;int stk[N], top;bool in_stk[N];int id[N], scc_cnt;int din[N], dout[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u, in_stk[u] = true; for (int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if (!dfn[j]) &#123; tarjan(j); low[u] = min(low[u], low[j]); &#125; else if (in_stk[j]) low[u] = min(low[u], dfn[j]); &#125; if (dfn[u] == low[u]) &#123; ++ scc_cnt; int y; do &#123; y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; &#125; while (y != u); &#125;&#125;int main()&#123; cin &gt;&gt; n; memset(h, -1, sizeof h); for (int i = 1; i &lt;= n; i ++ ) &#123; int t; while (cin &gt;&gt; t, t) add(i, t); &#125; for (int i = 1; i &lt;= n; i ++ ) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i ++ ) for (int j = h[i]; j != -1; j = ne[j]) &#123; int k = e[j]; int a = id[i], b = id[k]; if (a != b) &#123; dout[a] ++ ; din[b] ++ ; &#125; &#125; int a = 0, b = 0; for (int i = 1; i &lt;= scc_cnt; i ++ ) &#123; if (!din[i]) a ++ ; if (!dout[i]) b ++ ; &#125; printf(\"%d\\n\", a); if (scc_cnt == 1) puts(\"0\"); else printf(\"%d\\n\", max(a, b)); return 0;&#125; 最大半连接子图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;using namespace std;typedef long long LL;const int N = 100010, M = 2000010;int n, m, mod;int h[N], hs[N], e[M], ne[M], idx;int dfn[N], low[N], timestamp;int stk[N], top;bool in_stk[N];int id[N], scc_cnt, scc_size[N];int f[N], g[N];void add(int h[], int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u, in_stk[u] = true; for (int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if (!dfn[j]) &#123; tarjan(j); low[u] = min(low[u], low[j]); &#125; else if (in_stk[j]) low[u] = min(low[u], dfn[j]); &#125; if (dfn[u] == low[u]) &#123; ++ scc_cnt; int y; do &#123; y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; scc_size[scc_cnt] ++ ; &#125; while (y != u); &#125;&#125;int main()&#123; memset(h, -1, sizeof h); memset(hs, -1, sizeof hs); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;mod); while (m -- ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(h, a, b); &#125; for (int i = 1; i &lt;= n; i ++ ) if (!dfn[i]) tarjan(i); unordered_set&lt;LL&gt; S; // (u, v) -&gt; u * 1000000 + v for (int i = 1; i &lt;= n; i ++ ) for (int j = h[i]; ~j; j = ne[j]) &#123; int k = e[j]; int a = id[i], b = id[k]; LL hash = a * 1000000ll + b; if (a != b &amp;&amp; !S.count(hash)) &#123; add(hs, a, b); S.insert(hash); &#125; &#125; for (int i = scc_cnt; i; i -- ) &#123; if (!f[i]) &#123; f[i] = scc_size[i]; g[i] = 1; &#125; for (int j = hs[i]; ~j; j = ne[j]) &#123; int k = e[j]; if (f[k] &lt; f[i] + scc_size[k]) &#123; f[k] = f[i] + scc_size[k]; g[k] = g[i]; &#125; else if (f[k] == f[i] + scc_size[k]) g[k] = (g[k] + g[i]) % mod; &#125; &#125; int maxf = 0, sum = 0; for (int i = 1; i &lt;= scc_cnt; i ++ ) if (f[i] &gt; maxf) &#123; maxf = f[i]; sum = g[i]; &#125; else if (f[i] == maxf) sum = (sum + g[i]) % mod; printf(\"%d\\n\", maxf); printf(\"%d\\n\", sum); return 0;&#125;","permalink":"http://yoursite.com/2020/07/22/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"LCA初学","date":"2020/07/21","text":"重新拾起鸽了超级久的博客，至此开始贴代码水文生活 祖孙询问LCA裸题，没什么好说的 树上倍增法树上倍增基于以下公式:$$F[x,k]=F[F[x,k-1],k-1] (\\forall k\\epsilon [1,logn])$$F[x,k]表示x的2^k^辈祖先，即从x向根节点走2^k^步到达的节点 (为什么markdown无法识别latex公式呢。。。) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010, M = N * 2;int n, m;int h[N], e[M], ne[M], idx;int depth[N], fa[N][16];int q[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void bfs(int root)&#123; memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[root] = 1; int hh = 0, tt = 0; q[0] = root; while (hh &lt;= tt) &#123; int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; if (depth[j] &gt; depth[t] + 1) &#123; depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; for (int k = 1; k &lt;= 15; k ++ ) fa[j][k] = fa[fa[j][k - 1]][k - 1]; //这里倍增，通过二进制完成了距离的简化 &#125; &#125; &#125;&#125;int lca(int a, int b)&#123; if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 15; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; if (a == b) return a; for (int k = 15; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) &#123; a = fa[a][k]; b = fa[b][k]; &#125; return fa[a][0];&#125;int main()&#123; scanf(\"%d\", &amp;n); int root = 0; memset(h, -1, sizeof h); for (int i = 0; i &lt; n; i ++ ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (b == -1) root = a; else add(a, b), add(b, a); &#125; bfs(root); scanf(\"%d\", &amp;m); while (m -- ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int p = lca(a, b); if (p == a) puts(\"1\"); else if (p == b) puts(\"2\"); else puts(\"0\"); &#125; return 0;&#125; 距离123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 10010, M = N * 2;int n, m;int h[N], e[M], w[M], ne[M], idx;int dist[N];int p[N];int res[M];int st[N];vector&lt;PII&gt; query[N]; void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;void dfs(int u, int fa)&#123; for (int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if (j == fa) continue; dist[j] = dist[u] + w[i]; dfs(j, u); &#125;&#125;int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;void tarjan(int u)&#123; st[u] = 1; for (int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; tarjan(j); p[j] = u; &#125; &#125; for (auto item : query[u]) &#123; int y = item.first, id = item.second; if (st[y] == 2) &#123; int anc = find(y); res[id] = dist[u] + dist[y] - dist[anc] * 2; &#125; &#125; st[u] = 2;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); add(a, b, c), add(b, a, c); &#125; for (int i = 0; i &lt; m; i ++ ) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (a != b) &#123; query[a].push_back(&#123;b, i&#125;); query[b].push_back(&#123;a, i&#125;); &#125; &#125; for (int i = 1; i &lt;= n; i ++ ) p[i] = i; dfs(1, -1); tarjan(1); for (int i = 0; i &lt; m; i ++ ) printf(\"%d\\n\", res[i]); return 0;&#125; 次小生成树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010, M = 300010, INF = 0x3f3f3f3f;int n, m;struct Edge&#123; int a, b, w; bool used; bool operator&lt; (const Edge &amp;t) const &#123; return w &lt; t.w; &#125;&#125;edge[M];int p[N];int h[N], e[M], w[M], ne[M], idx;int depth[N], fa[N][17], d1[N][17], d2[N][17];int q[N];void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;LL kruskal()&#123; for (int i = 1; i &lt;= n; i ++ ) p[i] = i; sort(edge, edge + m); LL res = 0; for (int i = 0; i &lt; m; i ++ ) &#123; int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w; if (a != b) &#123; p[a] = b; res += w; edge[i].used = true; &#125; &#125; return res;&#125;void build()&#123; memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i ++ ) if (edge[i].used) &#123; int a = edge[i].a, b = edge[i].b, w = edge[i].w; add(a, b, w), add(b, a, w); &#125;&#125;void bfs()&#123; memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[1] = 1; q[0] = 1; int hh = 0, tt = 0; while (hh &lt;= tt) &#123; int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) &#123; int j = e[i]; if (depth[j] &gt; depth[t] + 1) &#123; depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; d1[j][0] = w[i], d2[j][0] = -INF; for (int k = 1; k &lt;= 16; k ++ ) &#123; int anc = fa[j][k - 1]; fa[j][k] = fa[anc][k - 1]; int distance[4] = &#123;d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]&#125;; d1[j][k] = d2[j][k] = -INF; for (int u = 0; u &lt; 4; u ++ ) &#123; int d = distance[u]; if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d; else if (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d; &#125; &#125; &#125; &#125; &#125;&#125;int lca(int a, int b, int w)&#123; static int distance[N * 2]; int cnt = 0; if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 16; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) &#123; distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; a = fa[a][k]; &#125; if (a != b) &#123; for (int k = 16; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) &#123; distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; distance[cnt ++ ] = d1[b][k]; distance[cnt ++ ] = d2[b][k]; a = fa[a][k], b = fa[b][k]; &#125; distance[cnt ++ ] = d1[a][0]; distance[cnt ++ ] = d1[b][0]; &#125; int dist1 = -INF, dist2 = -INF; for (int i = 0; i &lt; cnt; i ++ ) &#123; int d = distance[i]; if (d &gt; dist1) dist2 = dist1, dist1 = d; else if (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d; &#125; if (w &gt; dist1) return w - dist1; if (w &gt; dist2) return w - dist2; return INF;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); edge[i] = &#123;a, b, c&#125;; &#125; LL sum = kruskal(); build(); bfs(); LL res = 1e18; for (int i = 0; i &lt; m; i ++ ) if (!edge[i].used) &#123; int a = edge[i].a, b = edge[i].b, w = edge[i].w; res = min(res, sum + lca(a, b, w)); &#125; printf(\"%lld\\n\", res); return 0;&#125;","permalink":"http://yoursite.com/2020/07/21/LCA%E5%88%9D%E5%AD%A6/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"trie字典树和ac自动机","date":"2020/05/19","text":"字典树是一种实现字符串快速查找的多叉树结构","permalink":"http://yoursite.com/2020/05/19/trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8Cac%E8%87%AA%E5%8A%A8%E6%9C%BA/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 641&&642 回顾","date":"2020/05/16","text":"又到周末了，把最近打的cf没补的题目在假期补了，顺带水一发博客，感觉最近的cf没以前这么难了？ round 641链接codeforces round 641 C分析：找到序列两两组合形成的新的序列的最大公约数，其实观察我们可以知道这个数就是先找到原序列的最大公约数，然后再找到任意n-1个数与公约数之商组成的新的公约数的最大值，两者之积就是结果，时间复杂度O(n*logv) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn=100005;int n;ll a[maxn];ll pre[maxn],suf[maxn];ll gcd(ll x, ll y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;ll ga,ans;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); pre[1]=a[1]; suf[n]=a[n]; for(int i=2;i&lt;=n;i++) pre[i]=gcd(pre[i-1],a[i]); for(int i=n-1;i&gt;=1;i--) suf[i]=gcd(suf[i+1],a[i]); for(int i=0;i&lt;=n-1;i++) &#123; if(i==0) ans=suf[2]; else if(i==n-1) ans=ans*pre[n-1]/gcd(pre[n-1],ans); else ans=ans*gcd(pre[i],suf[i+2])/gcd(gcd(pre[i],suf[i+2]),ans); //求ans与gcd(pre[i],suf[i+2])的最小公倍数。。。 &#125; printf(\"%lld\\n\",ans); return 0;&#125; D分析：这道题虽然放在了这个位置，但是真正的难点就在能不能想到转化上，想到之后难度绝对低于C，原问题可以转化为能不能将原序列中的任意两个数变成连续的k，我们想一下，如何转化，实际上很简单，对于两个连续的值，得出的最终变换结果必定是当中较小的值，只需要找到初始位置上任意连续两点的值大于或者等于k就行了,按照这个思路，问题就迎刃而解了 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define IOS std::ios::sync_with_stdio(false)#define ll long long#pragma GCC optimize(2)using namespace std;const int N = 1e5 + 10;ll n,k;ll a[N];vector&lt;int&gt; pos;signed main()&#123; IOS ; int t; cin&gt;&gt;t; while(t--)&#123; pos.clear(); cin&gt;&gt;n&gt;&gt;k; int fl=1,sig=0; for (int i = 1; i &lt;=n ; ++i) &#123; cin&gt;&gt;a[i]; if(a[i]^k)fl=0; else&#123; //找到和k相同的 sig=1; &#125; &#125; if(sig==0)&#123; cout&lt;&lt;\"no\"&lt;&lt;endl; continue; &#125; for (int i = 1; i &lt;=n-1 ; ++i) &#123; if(a[i]&lt;k)continue; if(a[i+1]&gt;=k||(i&lt;=n-2&amp;&amp;a[i+2]&gt;=k))&#123; fl=1; break; &#125; &#125; if(fl)cout&lt;&lt;\"yes\"&lt;&lt;endl; else cout&lt;&lt;\"no\"&lt;&lt;endl; &#125; return 0 ;&#125; round 642链接codeforces round 642O D分析：单调队列+模拟，时间复杂度O(n*logn)，单调队列这个玩意实在有点玄学，至今不怎么会用，要临场学 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;typedef double db;const ll mod=1000000007;/* mt19937 mrand(random_device&#123;&#125;());int rnd(int x) &#123; return mrand() % x;&#125;*/ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; for(;b&gt;0;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; 48 || ch &gt; 57) &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (ch &gt;= 48 &amp;&amp; ch &lt;= 57) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return s * w;&#125;const int N=1e6+3;int T,n,m,k;int a[N];struct node&#123; int u,z,y; bool operator&lt;(const node&amp; b)const //重载'&lt;'号 &#123; if (u != b.u) return u &lt; b.u; //长度优先 return z &gt; b.z; //否则左节点靠前的优先 &#125;·&#125;;priority_queue&lt;node&gt; lpt;int main()&#123; scanf(\"%d\",&amp;T); while(T--)&#123; cin&gt;&gt;n; lpt.push(&#123;n,1,n&#125;); k=1; while(lpt.size())&#123; node x=lpt.top(); lpt.pop(); int l=x.z,r=x.y; int kevin=(l+r)/2; a[kevin]=k++; if(kevin!=l) lpt.push(&#123;(kevin-l),l,kevin-1&#125;); //存左段 if(kevin!=r) lpt.push(&#123;(r-kevin),kevin+1,r&#125;); //存右段 &#125; rep(i,1,n+1)&#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; puts(\" \"); &#125;&#125; E这回后面两题全部都是dp题目，甚至有时我觉得这两题的比div.2的C,D还要适合我的水准 分析：对于E我们可以采取前缀和记录1的数量，对于每个字符串，我们都可以将它分成不同的三截，前后两节都是0，中间部分是长度为k的循环节，我们要做的事情，就是判断怎么将这个字符串分成我们想要的情况，我们仔细观察会发现，所有的变化都可以视为k种情况的变种，即从第i个开始有了循环节，由此我们先算出所有灯开着的数量，然后按照1~k不同出发点对其进行判断，只需要处理处在循环节点上的灯就可以得出结果了，这就是第一种解法，时间复杂度O(k*(n/k))==O(n) 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;char s[N];signed main()&#123; ios::sync_with_stdio(false); int t; cin &gt;&gt; t; while(t --) &#123; int n , k , sum = 0 , ans = 0x3f3f3f3f; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s + 1; for(int i = 1 ; i &lt;= n ; i ++) sum += s[i] - '0'; for(int i = 1 ; i &lt;= k ; i ++) &#123; int cnt = 0; for(int j = i ; j &lt;= n ; j +=k) &#123; if(s[j] == '1') cnt -- ; else cnt ++ ; cnt = min(cnt , 0); //这个地方什么意思呢，就是当前情况下我们 ans = min(ans , sum + cnt); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\\n' ; &#125; return 0;&#125; 第二种解法是dp,看起来就不好理解，时间复杂度也是O(n) dp [i] [0]表示在第i个点将其变成0情况下的最小值，dp [i] [1]反之，大概的意思和前面的是一样的 dp [i] [0]就是第一段和第三段的计算 dp [i] [1]是对于第二段的判断，重点在于 p=max(0,i-k) 和dp [i] [1] = min(pre[i-1],dp[i] [0]+pre[i-1]+pre[p])+(s[i]==’0’) 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int pre[N] , dp[N][2];char s[N];signed main()&#123; ios::sync_with_stdio(false); int t; cin &gt;&gt; t; while(t --) &#123; int n , k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s + 1; for(int i = 1 ; i &lt;= n ; i ++) pre[i] = pre[i - 1] + s[i] - '0'; //一样的前缀和操作，但是这次要保存每个点的状态 for(int i = 1 ; i &lt;= n ; i ++) &#123; int p = max(0 , i - k); dp[i][0] = min(dp[i - 1][0] , dp[i - 1][1]) + (s[i] == '1'); dp[i][1] = min(pre[i - 1] , dp[p][1] + pre[i - 1] - pre[p]) + (s[i] == '0'); &#125; cout &lt;&lt; min(dp[n][0] , dp[n][1]) &lt;&lt; '\\n' ; for(int i = 0 ; i &lt;= n ; i ++) dp[i][0] = dp[i][1] = pre[i] = 0; &#125; return 0;&#125; F分析：刚开始以为只是个简单的数字三角形模板的变化形态，结果就罚坐发呆了一小时，还没写出个所以然出来，结果以看题解，人都傻了，比我想得还是要复杂很多","permalink":"http://yoursite.com/2020/05/16/codeforces-round-641-642-%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"可持续化数据结构","date":"2020/05/07","text":"便于得知数据集过去状态的一种方式，假设存在m次变化，当我们想知道过去的所有情况下的变化时，可以将数据结构拷贝一份，多耗费m倍空间","permalink":"http://yoursite.com/2020/05/07/%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"二叉查找树和平衡树初步","date":"2020/05/04","text":"终于划水划到平衡树了，学完了就先去做题，不强看书了,囫囵吞枣的学法难受且不实在，我是勤劳的进阶指南搬运工 BST(二叉查找树)性质对于任意一个节点，都能满足两个条件 该节点的关键码不小于它的左子树任意节点的关键码 该节点的关键码不大于它的右子树任意节点的关键码 建立首先建立两个其实节点，其关键码分别为无穷小和无穷大 1234567891011121314struct node&#123; int l,r,val;&#125;a[N];int tot,root,INF=1&lt;&lt;30;int new(int val)&#123; a[++tot].val=val; return tot;&#125;void build()&#123; new(INF),new(-INF); root=1,a[1].r=2;&#125; 检查寻找二叉树是否存在关键码为val的节点 若p的关键码为val，表示已经找到 若p的关键码大于val 若p的左节点为空，说明不存在val 若p的左节点不为空，在左子树中进行递归查找 若p的关键码小于val，和上一步正好反过来 12345int get(int p,int val)&#123; if(p==0) return 0; //左右节点为空 if(val==a[p].val) return p; return val&lt; p.val? get(p.l,val):get(p.r,val); &#125; 插入在发现要走的节点为空是，直接插入新的节点 123456789void insert(int &amp;p,int val) &#123; //引用 if(p==0) &#123; new(p,val); return; &#125; if(a[p].val==val) return; else if(a[p].val&lt;val) insert(a[p].r,val); else insert(a[p].l,val);&#125; 求前驱后继求后继：val的后继指的是在BST中关键码大于val的情况下，关键码最小的节点 没有找到val,说明val的后继已经在所遍历的节点中，ans即为所求 找到了关键码为val的节点p,且该节点没有右子树，结果和1一样 找到了val节点p，从它的右子节点开始遍历，从左走，就找到了val的后继 1234567891011121314151617int getnext(int val)&#123; int ans=0; //a[w].val=INF; int p=root; //root=1,v[root].val是-INF while(p)&#123; if(val==a[p].val)&#123; if(a[p].r&gt;0)&#123; p=a[p].r; while(a[p].l&gt;0) p=a[p].l; ans=p; &#125; break; &#125; if(a[p].val&gt;val&amp;&amp;a[p].val&lt;a[ans].val) ans=p; p=val&lt;a[p].val?a[p].l:a[p].r; &#125; return ans;&#125; 节点删除 现在节点中寻找val,得到节点p 若p的子节点数小于二，那么直接删除P，令p的子节点代替p的位置 若p既有左子树又有右子树，那么就先求出val的后继节点next,然后直接删除next(没有左子树)，并令next的右子树代替next的位置，最后让next节点代替p，删除p即可 12345678910111213141516171819202122void remove(int val)&#123; int &amp;p=root; //先找寻val while(p)&#123; if(val==a[p].val) break; p=val&lt;a[p].val?a[p].l:a[p].r; &#125; if(p==0)return; //不存在 if(a[p].l==0)&#123; //没有左子树，直接右子树代替 p=a[p].r; &#125; else if(a[p].r==0)&#123;//没有右子树，左子树代替 p=a[p].l; &#125; else&#123;//左右子树都有 int next=a[p].r;//找后继 while(a[next].l&gt;0) next=a[next].l; remove(a[next].val);//next节点必定没有左节点，删掉即可 a[next].l=a[p].l,a[next].r=a[p].r; //next继承p的左右节点 p=next;//删除p &#125;&#125; 平衡树性质满足二叉查找树性质且左右子树大小达到平衡，从而使得整棵树的深度维持在O(logN)级别 treap左右旋假设x是y的左子节点，AB分别是x的左右子树，C是y的右子树 在维持BST的基础上，把x变成y的父节点。y变成x的右子树，B变成y的左子树 12345678910void zig(int &amp;y)&#123; //左旋 int x=a[y].l; //把x求出 a[y].l=a[x].r,a[x].r=y; //交换左右树 y=x;&#125;void zag(int &amp;y)&#123; int x=a[y].r; a[y].r=a[x].l,a[x].l=y; y=x;&#125; 题目普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//ycx的代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, INF = 1e8;int n;struct Node&#123; int l, r; int key, val; int cnt, size;&#125;tr[N];int root, idx;void pushup(int p)&#123; tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;&#125;int get_node(int key)&#123; tr[ ++ idx].key = key; tr[idx].val = rand(); tr[idx].cnt = tr[idx].size = 1; return idx;&#125;void zig(int &amp;p) // 右旋&#123; int q = tr[p].l; tr[p].l = tr[q].r, tr[q].r = p, p = q; pushup(tr[p].r), pushup(p);&#125;void zag(int &amp;p) // 左旋&#123; int q = tr[p].r; tr[p].r = tr[q].l, tr[q].l = p, p = q; //之前一直对这个东西保有疑惑，后面发现必须要配合insert(&amp;p,val)和remove(&amp;p，key)来理解 pushup(tr[p].l), pushup(p);&#125;void build()&#123; get_node(-INF), get_node(INF); root = 1, tr[1].r = 2; pushup(root); if (tr[1].val &lt; tr[2].val) zag(root);&#125;void insert(int &amp;p, int key)&#123; if (!p) p = get_node(key); else if (tr[p].key == key) tr[p].cnt ++ ; else if (tr[p].key &gt; key) &#123; insert(tr[p].l, key); if (tr[tr[p].l].val &gt; tr[p].val) zig(p); &#125; else &#123; insert(tr[p].r, key); if (tr[tr[p].r].val &gt; tr[p].val) zag(p); &#125; pushup(p);&#125;void remove(int &amp;p, int key)&#123; if (!p) return; if (tr[p].key == key) &#123; if (tr[p].cnt &gt; 1) tr[p].cnt -- ; else if (tr[p].l || tr[p].r) &#123; if (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) &#123; zig(p); remove(tr[p].r, key); &#125; else &#123; zag(p); remove(tr[p].l, key); &#125; &#125; else p = 0; &#125; else if (tr[p].key &gt; key) remove(tr[p].l, key); else remove(tr[p].r, key); pushup(p);&#125;int get_rank_by_key(int p, int key) // 通过数值找排名&#123; if (!p) return 0; // 本题中不会发生此情况 if (tr[p].key == key) return tr[tr[p].l].size + 1; if (tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key); return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);&#125;int get_key_by_rank(int p, int rank) // 通过排名找数值&#123; if (!p) return INF; // 本题中不会发生此情况 if (tr[tr[p].l].size &gt;= rank) return get_key_by_rank(tr[p].l, rank); if (tr[tr[p].l].size + tr[p].cnt &gt;= rank) return tr[p].key; return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);&#125;int get_prev(int p, int key) // 找到严格小于key的最大数&#123; if (!p) return -INF; if (tr[p].key &gt;= key) return get_prev(tr[p].l, key); return max(tr[p].key, get_prev(tr[p].r, key));&#125;int get_next(int p, int key) // 找到严格大于key的最小数&#123; if (!p) return INF; if (tr[p].key &lt;= key) return get_next(tr[p].r, key); return min(tr[p].key, get_next(tr[p].l, key));&#125;int main()&#123; build(); scanf(\"%d\", &amp;n); while (n -- ) &#123; int opt, x; scanf(\"%d%d\", &amp;opt, &amp;x); if (opt == 1) insert(root, x); else if (opt == 2) remove(root, x); else if (opt == 3) printf(\"%d\\n\", get_rank_by_key(root, x) - 1); else if (opt == 4) printf(\"%d\\n\", get_key_by_rank(root, x + 1)); else if (opt == 5) printf(\"%d\\n\", get_prev(root, x)); else printf(\"%d\\n\", get_next(root, x)); &#125; return 0;&#125; 小记(2020.5.4)二叉查找加treap平衡树，blog已经更新（抄y总代码），说实话，只是看了一遍代码，能基本的运用都不熟练，更别说变化了，可能是我对难度的估计太过乐观，明天还是回头把线段树有关的内容补完吧，要一步一步地来，一口吃不成胖子","permalink":"http://yoursite.com/2020/05/04/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%88%9D%E6%AD%A5/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"线段树&树状数组初学","date":"2020/05/02","text":"鼓捣了三天才勉强算是入个门，这里就算是借大佬们的代码来给自己加深一下理解吧 线段树基本模板这里是一个序列求和的板子，算是最基础的吧，含lazy 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int N=10000; //这个板子应该是求区间和的经典板子int _;struct node&#123; ll l,r,w,flag; node() &#123;&#125;; node(int _l,int _r,int _w,int _f) &#123;flag=_f,l=_l,r=_r,w=_w;&#125; ll mid()&#123;return (l+r)/2;&#125;&#125;;node a[N&lt;&lt;2];void build(ll k,ll l,ll r)&#123; a[k]=node(l,r,0,0); //新的区间 if(a[k].l==a[k].r)&#123; //找到叶节点，将输入的值输进去，这里面很巧妙的使用了先建立左边板子的条件 cin&gt;&gt;a[k].w; return; //叶节点不再存在有子节点，直接回溯 &#125; build(k&lt;&lt;1,l,(l+r)/2); //此处依然不是根节点，找左边的子区间 build(k&lt;&lt;1|1,(l+r)/2,r); //找右边的的子区间 a[k].w=a[k&lt;&lt;1].w+a[k&lt;&lt;1|1].w; //当左右两边的子区间的值都求出来之后，就可以求父区间的值了&#125;void down(int k)&#123; //这里是延迟标记。。。相当于把原本应该加上去的值给传递下去，之前是因为访问太麻烦了 a[k&lt;&lt;1].flag+=a[k].flag; //左端子节点加上父节点的标记值 a[k&lt;&lt;1|1].flag+=a[k].flag; //现在是右节点 a[k&lt;&lt;1].w+=a[k].flag*(a[k&lt;&lt;1].r-a[k&lt;&lt;1|1].l+1); //价值等于父节点的标记值加上自己的元素数量 a[k&lt;&lt;1|1].w+=a[k].flag*(a[k&lt;&lt;1].r-a[k&lt;&lt;1|1].l+1);//现在是右边的节点 a[k].flag=0; //取消标记，当前任务完成&#125;int res;void update(int k,int x,int y,int z)&#123; //区间更新，k为访问到的子节点，x,y是改变的的区间，z是更新的值？ if(a[k].l&gt;=x&amp;&amp;a[k].r&lt;=y)&#123; //当前区间被改变区间完全覆盖，应该全部加上z a[k].w+=z*(a[k].r-a[k].l+1); a[k].flag+=z; //继承标记，但是还没向下传递 return; &#125; if(a[k].flag) //如果之前已经出现了延迟标记，先将标记传递下去 down(k); if(x&lt;a[k].mid()) //没能完全覆盖，就只能继续寻找对应的子节点 update(k&lt;&lt;1,x,y,z); if(y&gt;a[k].mid()) //这是右节点 update(k&lt;&lt;1|1,x,y,z); a[k].w=a[k&lt;&lt;1].w+a[k&lt;&lt;1|1].w; //当被改变区间能覆盖的最上层结果被改变之后，递归结束，上层的值也要被改变。延迟传递只能由上往下&#125;int ans;void query(int k,int x,int y)&#123; //查询一段区间的值 if(a[k].l&gt;=x&amp;&amp;a[k].r&lt;=y)&#123; //覆盖就直接加上当前节点的值，没有必要继续往下 res+=a[k].w; return; &#125; if(a[k].flag) //没有覆盖，并且有标记标记，更新下一段 down(k); if(x&lt;=a[k].mid()) //完成更新之后，找寻子节点当中符合标准的 query(k&lt;&lt;1,x,y); if(y&gt;a[k].mid()) query(k&lt;&lt;1|1,x,y); a[k].w=a[k&lt;&lt;1].w+a[k&lt;&lt;1|1].w; &#125; 应用区间求最大值，线段树增加元素公式推导： t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; t[p].lmax=max(t[p&lt;&lt;1].lmax,t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].lmax); t[p].rmax=max(t[p&lt;&lt;1|1]rmax,tp[p&lt;&lt;1|1].sum+tp[p&lt;&lt;1].rmax); t[p].dat=max(t[p&lt;&lt;1].dat,t[p&lt;&lt;1|1].dat,t[p&lt;&lt;1].rmax+t[p&lt;&lt;1|1].lmax); 这一题和经典板子的区别在于使用的pushup函数不一样，所以要设置两种pushup函数，一种情况用于建树，另一种用于查询 acwing 1275.最大数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 500010;int n, m;int w[N];struct Node&#123; int l, r; int sum, lmax, rmax, tmax;&#125;tr[N * 4];void pushup(Node &amp;u, Node &amp;l, Node &amp;r)&#123; u.sum = l.sum + r.sum; u.lmax = max(l.lmax, l.sum + r.lmax); u.rmax = max(r.rmax, r.sum + l.rmax); u.tmax = max(max(l.tmax, r.tmax), l.rmax + r.lmax);&#125;//非常规情况void pushup(int u)&#123; pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);&#125;//常规情况void build(int u, int l, int r)&#123; if (l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125;&#125;void modify(int u, int x, int v)&#123; if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125;&#125;Node query(int u, int l, int r)&#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u]; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (r &lt;= mid) return query(u &lt;&lt; 1, l, r); else if (l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r); else &#123; auto left = query(u &lt;&lt; 1, l, r); auto right = query(u &lt;&lt; 1 | 1, l, r); Node res; pushup(res, left, right); return res; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;w[i]); build(1, 1, n); int k, x, y; while (m -- ) &#123; scanf(\"%d%d%d\", &amp;k, &amp;x, &amp;y); if (k == 1) &#123; if (x &gt; y) swap(x, y); printf(\"%d\\n\", query(1, x, y).tmax); &#125; else modify(1, x, y); &#125; return 0;&#125; 扫描线链接：亚特兰蒂斯 首先用n个矩形的x,y轴端点来划分出区域 以x轴的坐标点之间的线段作为元素，y轴的作为扫描线，一个矩形的左端扫描线使得它所覆盖的区域cnt+1,右端cnt-1,用每段线段长度乘以它所处范围当中cnt&gt;=0的部分 最终全长即为目标值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;int n;struct Segment&#123; double x, y1, y2; int k; bool operator&lt; (const Segment &amp;t)const &#123; return x &lt; t.x; &#125;&#125;seg[N * 2];struct Node //扫描线&#123; int l, r; //扫描线的上端下端 int cnt; //扫描线是矩形左端还是右端 double len;&#125;tr[N&lt;&lt;3];vector&lt;double&gt; ys;int find(double y)&#123; return lower_bound(ys.begin(), ys.end(), y) - ys.begin();&#125;void pushup(int u)&#123; if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l]; else if (tr[u].l != tr[u].r) &#123; tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len; &#125; else tr[u].len = 0;&#125;void build(int u, int l, int r)&#123; tr[u] = &#123;l, r, 0, 0&#125;; if (l != r) &#123; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); &#125;&#125;void modify(int u, int l, int r, int k)&#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].cnt += k; pushup(u); &#125; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k); pushup(u); &#125;&#125;int main()&#123; int T = 1; while (scanf(\"%d\", &amp;n), n) &#123; ys.clear(); for (int i = 0, j = 0; i &lt; n; i ++ ) &#123; double x1, y1, x2, y2; scanf(\"%lf%lf%lf%lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); seg[j ++ ] = &#123;x1, y1, y2, 1&#125;; seg[j ++ ] = &#123;x2, y1, y2, -1&#125;; ys.push_back(y1), ys.push_back(y2); &#125; sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end()); build(1, 0, ys.size() - 2); sort(seg, seg + n * 2); double res = 0; for (int i = 0; i &lt; n * 2; i ++ ) &#123; if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x); modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k); &#125; printf(\"Test case #%d\\n\", T ++ ); printf(\"Total explored area: %.2lf\\n\\n\", res); &#125; return 0;&#125; 动态开点和线段树合并从kevin那搞得，不然真的猝死了 动态开点12345678910111213141516171819202122232425262728293031323334353637#define ll long longconst int N=1e7+50;const ll inf=2e14;int n,m;ll t,sum,ans=0;int rt,ls[N],rs[N],num[N],cnt;void update(int &amp;p,ll l,ll r,ll pos)&#123; if(!p) p=++cnt; num[p]++; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(ls[p],l,mid,pos); else update(rs[p],mid+1,r,pos);&#125;int query(int p,ll l,ll r,ll L,ll R)&#123; if(!p) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return num[p]; int res=0; ll mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(ls[p],l,mid,L,R); if(R&gt;mid) res+=query(rs[p],mid+1,r,L,R); return res;&#125;int main()&#123; scanf(\"%d%lld\",&amp;n,&amp;t); update(rt,-inf,inf,0); for(int i=1;i&lt;=n;++i)&#123; scanf(\"%d\",&amp;m); sum+=m; ans+=query(rt,-inf,inf,sum-t+1,inf); update(rt,-inf,inf,sum); &#125; printf(\"%lld\\n\",ans);&#125; 合并线段树两个维护相同值域的线段树，都含有log[n]次操作,那么我们可以将他们合并起来 12345678910111213int merge(int p,int q,int l,int r)&#123; if(!p) return p; if(!q) return 1; if(p==q)&#123; tr1[p].dat+=tr2[q].dat; return p; &#125; int mid=(l+r)&gt;&gt;1; tr1[p].lc=merge(tr1[p].lc,tr2[q].lc,l,mid); tr1[p].rc=merge(tr1[p].rc,tr2[q].rc,mid+1,r); tr1[p].dat=max(tr1[tr[p].lc].dat,tr1[tr1[q].rc].dat);//更新 return p;&#125; 树状数组一阶123456789ll sum(ll x)&#123; //求前缀和 ll ans=0; for(;x;x-=x&amp;x) ans+=c[x]; return ans;&#125;void add(ll x,ll y)&#123; //单点增加 for(;x&lt;=N;x+=x&amp;x) c[x]+=y;&#125; 树状数组与逆序对求序列当中的逆序对有多少 在序列的数字范围中建立树状数组，初始化为零 正序扫描给定的序列，对于每个序列中的数字a[i] 在树状数组中查询前缀和c[n]-c[a[i]],累加到ans中 执行单点增加操作，即把a[i]位置上又加一次 这个方法适合序列中的数据范围不大时的情况，复杂度为O(NlogM),否则应该使用归并排序的方法求逆序对 楼兰图腾 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 200010;int n;int a[N];int tr[N];int Greater[N], lower[N];int lowbit(int x) //lowbit函数求最低位&#123; return x &amp; -x;&#125;void add(int x, int c) //单点增加&#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;&#125;int sum(int x) //区间求和&#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res;&#125;int main()&#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) &#123; int y = a[i]; Greater[i] = sum(n) - sum(y); lower[i] = sum(y - 1); add(y, 1); &#125; memset(tr, 0, sizeof tr); //清空，再来 LL res1 = 0, res2 = 0; for (int i = n; i; i -- ) &#123; int y = a[i]; res1 += Greater[i] * (LL)(sum(n) - sum(y)); res2 += lower[i] * (LL)(sum(y - 1)); add(y, 1); &#125; printf(\"%lld %lld\\n\", res1, res2); return 0;&#125; 树状数组适合单点增加和区间查询，如果实现区间增加和单点查询，可以建立一个差分树状数组，求其前缀和即为变化值 2020.5.7 小记从下定决心打好acm这个目标开始已经过去了一个月了，过去的一个月较以往来说确实是截然不同，我初次体会到了作为一个ACMer所体会到的生活，学习了一些基础的算法，cf也都一场不落地参加了，更重要的是认识到了一群共同努力的同龄人，在他们身上我看到了属于这个年龄段本该有的朝气和毅力，真心地佩服他们。这是我从高中毕业以来久久没有没有看到过的场景，只可惜那时我都沉湎于娱乐世界中不可自拔，以所谓的迷茫来做逃避和麻醉，其实青年人努力学习，挑战自我才是正确的旋律。ACM是一项纯粹的竞赛运动，重要的是我们在这段经历中体验到了什么，领悟到了什么，它的核心除了刺激的比赛和令人欲罢不能的题目外，更重要的是在这一次次训练，比赛外带来的酸甜苦辣，和自己谱写出的有关青春的篇章吧。 训练时间安排： 双休： 8：00——12：00 14：00——18：00 19：00——23：30 工作日：晚上时间相同，其余的按照课表空余来","permalink":"http://yoursite.com/2020/05/02/%E7%BA%BF%E6%AE%B5%E6%A0%91&%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E5%AD%A6/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 636 div.2回顾","date":"2020/04/22","text":"昨晚的比赛感觉更像是div.2了。。。分类有点古怪 A题重要代码 123456scanf(\"%d\",&amp;m);int sum=1,k=1;while(m%sum)&#123; k&lt;&lt;=1; sum+=k;&#125; C题一道dp题目，但是更加直观的可能是模拟，列出四种情况，判断进行的操作，代码 123456789101112131415161718while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;it : a) cin &gt;&gt; it; long long sum = 0; for (int i = 0; i &lt; n; ++i) &#123; int cur = a[i]; int j = i; while (j &lt; n &amp;&amp; sgn(a[i]) == sgn(a[j])) &#123; cur = max(cur, a[j]); ++j; &#125; sum += cur; i = j - 1; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; D题这道题乍看起来不是很好操作，可以操作的点实在是太多了，但是我们可以观察到，对于一对数字a[i]和a[n-i+1]来说，最终的改变情况可能有四种(2^2)，综合来看我们可以得到最终总和的变化范围是 2-min(a[i],a[n-i+1])+1-a[i]+a[n-i+1]-max(a[i],a[n-i+1])+k-k*2(此处默认理想范围，不理想也没关系) 这里为什么是范围呢，因为我们并不能知道其他的元素能将这对数字变成具体的某个数字，只能确定的那个大概的范围，我们可以知道，如果出在了第一个阶段和第三个阶段，那么改变了两个数字，如果是处在第二阶段中，那么就是改变了一个数字，我们只要在2~k中处理前缀和，得到最终结果就可以了 代码： 1234567891011121314151617181920212223242526272829303132int main()&#123; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1;i&lt;=2*k;i++)cnt[i]=0; for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n/2;i++) &#123; cnt[1]+=2; //初始化为2，此时是最低值2的前缀，默认改变两次 cnt[min(a[i],a[n-i+1])+1]--; //当遇到低值至最高的范围中时没必要再改变两个，改变不在边上的就好了 cnt[max(a[i],a[n-i+1])+k+1]++; //超出最大最小值能够够得着的范围，只能两个都改变 cnt[a[i]+a[n-i+1]]--; //特判，当遇到不需要改变值的情况 cnt[a[i]+a[n-i+1]+1]++; //结束特判 &#125; int ans=n; for(int i=1;i&lt;=k*2;i++) //遍历，寻找k值，得到最小的ans &#123; cnt[i]+=cnt[i-1]; ans=min(ans,cnt[i]); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125; E题题意：无向图一张，求a到b到c最短需要多久，这个是已经给出了图，要我们找到最短路之后给他们设置给定的一组边长中的值，使得最短路仍然是最短路 分析：最短路，最短路，又是这玩意，看似好做，实则麻烦死。首先我们必须得到边权值全部为1时的最短路，再来给边路分配权值，对于由a-b-c这样的路径，对于图中的所有点n，都存在有路线先从a到n,再从n到b最后到c的情况，我们所要求的最小路径中最小权值必定优先满足n到b的路径，因为要经过其两次，也不是绝对的，比如当n到b的路径太长导致超过了其余的 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Edge&#123; int to; int nxt;&#125;e[400005];int t,n,m,a,b,c,edgenum,head[200005];int dis[3][200005];ll p[200005];queue&lt;int&gt;q;void add(int u,int v)&#123;//头插法的链接表（就是链表） e[++edgenum].to=v; e[edgenum].nxt=head[u]; head[u]=edgenum;&#125;void bfs(int st,int*dis)&#123; q.push(st); dis[st]=1; while(!q.empty()) &#123; int node=q.front(); q.pop(); for(int hd=head[node];hd;hd=e[hd].nxt) &#123; int to=e[hd].to; if(!dis[to]) &#123; dis[to]=dis[node]+1; q.push(to); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d%d%d%d\",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++)head[i]=dis[0][i]=dis[1][i]=dis[2][i]=0; edgenum=0; for(int i=1;i&lt;=m;i++)scanf(\"%lld\",&amp;p[i]); sort(p+1,p+m+1); for(int i=1;i&lt;=m;i++) &#123; p[i]+=p[i-1]; //这里存好长度为i的路径对应的最小值 int u,v; scanf(\"%d%d\",&amp;u,&amp;v); add(u,v); add(v,u); &#125; bfs(a,dis[0]); bfs(b,dis[1]); bfs(c,dis[2]); ll ans=1e18; for(int i=1;i&lt;=n;i++) &#123; if(dis[0][i]+dis[1][i]+dis[2][i]-3&gt;m)continue; //这个点，应该就是规避n到b的路径过长的问题吧，但是感觉没后面的好使 ans=min(ans,p[dis[1][i]-1]+p[dis[0][i]-1+dis[1][i]-1+dis[2][i]-1]); //配合p[i]对应的最小值，起飞 &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","permalink":"http://yoursite.com/2020/04/22/codeforces-round-636-div-2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"acwing","slug":"acwing","permalink":"http://yoursite.com/tags/acwing/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}],"title":"acwing 记录 第一章","date":"2020/04/20","text":"这里是acwing上面dp专题的价值题的收集，算是dp专题吧 275.传纸条链接：https://www.acwing.com/solution/acwing/content/2851/ 分析这道题是一道线性dp，求出不重合的两条路线的权值之和，我们可以设想为两个人在互不重合的路线上同时出发同时到达，设他们所处的坐标横纵之和为m+n，第一位的横坐标为i,第二位为j,对应的纵坐标就是m+n-i,m+n-j，由此我们可以确定状态f[k] [i] [j]，即坐标值和为k的时候两个人的权值之和的最大值，那么能够走到这一步有四种可能，分别为右右，右下，下右，下下，并且我们注意到，如果i==j,那么说明此时两个人的走到了同一位置，此时由于此种情况不可能存在，我们之间舍去即可 方法一暴力枚举加部分贪心，通过枚举左端的人的位置，由于右端的人不可能再从更左的地方出发（可能出发的情况早已经储存在了之前的状态之中），那么我们可得到四重循环的结果f[n-1] [m] [n-1] [m]，这样子有一个好处，可以避免对两人坐标相同时的讨论，但是复杂度仍然很高，无论是空间还是时间都是O(n^4) 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int v[55][55],f[55][55][55][55];// (i,j) 是第一条路径坐标 (k,l) 是第二条int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(\"%d\",&amp;v[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; for(int k=1;k&lt;=n;k++) &#123; for(int l=j+1;l&lt;=m;l++) &#123; int w1=f[i-1][j][k][l-1],w2=f[i-1][j][k-1][l]; int w3=f[i][j-1][k][l-1],w4=f[i][j-1][k-1][l]; f[i][j][k][l]=max(w1,max(w2,max(w3,w4)))+v[i][j]+v[k][l]; //我们用贪心思想可得两条路径肯定不相交 (能取数就取数) //那么令 l=(j+1,m) 即满足了此条件 (保证了第二条路线一定在第一条路线下面) //不用判重因为不会重两条路径不相交 &#125; &#125; &#125; &#125; printf(\"%d\",f[n][m-1][n-1][m]); //dp 是达不到 (n,m) 的,但 (n,m) 等价于 (n-1,m),(n,m-1) (因为 v(n,m)==0) return 0;&#125; 方法二就是设定总计的步数为k,两人坐标分别为(i,k-i) (j,k-j) 从而得到状态f[k] [i] [j] 当i != j时，此时两者处在不同的位置，那么就可以通过四种达到该状态的方式来得出f[k] [i] [j]的值，如果i==j，直接不做讨论，跳过完事，除非时i==j==0||n的情况 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55;int n, m;int g[N][N];int f[N * 2][N][N];int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(\"%d\", &amp;g[i][j]); for (int k = 2; k &lt;= n + m; k ++ ) for (int i = max(1, k - m); i &lt;min(n+1,k); i ++ ) for (int j = max(1, k - m); j &lt;min(n+1,k); j ++ ) for (int a = 0; a &lt;= 1; a ++ ) for (int b = 0; b &lt;= 1; b ++ ) &#123; int t = g[i][k - i]; if (i != j || k == 2 || k == n + m) &#123; t += g[j][k - j]; f[k][i][j] = max(f[k][i][j], f[k - 1][i - a][j - b] + t); &#125; &#125; printf(\"%d\\n\", f[n + m][n][n]); return 0;&#125; 总结方法一规避了对两者位置相同的时的判断，代码简化且方式粗暴，但是由于没有对步长的限制，导致了对时间和空间上的极大浪费，第二种方式通过对步长的限制，使得计算降低了一个维度 1014.登山链接：https://www.acwing.com/problem/content/description/1016/ 分析：这是一道经典的LIS题目，但是我们可以用双dp数组的思想来做，降低代码复杂度 方法：设置两个数组dp_high,dp_sum，前者dp_high[i]表示序列为i的元素结尾的序列的最长上升子序列长度，后者dp_sum[i]表示以i结尾的序列的最长先上升在下降序列长度 有状态转移方程：对任意j&lt;i if(a[j]&lt;a[i]) dp_high[i]=max(dp_high[i],dp_high[j]+1) else if(a[j]&gt;a[i]) dp_sum[i]=max(dp_sum[i],max(dp_sum[j]+1,dp_high[j]+1)) 时间复杂度没有明显降低，但是提供了一种嵌套迭代的思想 代码：123456789101112131415for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; h[i]; dp_inc[i] = 1, dp_dec[i] = 1; for(int j = 0; j &lt; i; ++j) &#123; if(h[j] &lt; h[i]) dp_inc[i] = max(dp_inc[i], dp_inc[j]+1); if(h[j] &gt; h[i]) dp_dec[i] = max(dp_dec[i], max(dp_inc[j]+1, dp_dec[j]+1)); &#125; res = max(res, max(dp_inc[i], dp_dec[i]));&#125; 1011.登山链接：https://www.acwing.com/problem/content/1012/ 分析：求最大上升子序列和最长不降子序列的长度，可以使用lower_bound和upper_bound两个函数，两者正常情况下的都是对升序列使用，如果需对降序列使用必须使用greater()或者重载模型 123456789对降序序列使用 lower_bound(f,f+n,a,greater&lt;int&gt;())求出第一个小于或等于a的f[n]的位置，没有返回end; upper_bound返回的是不能等于的数对结构体使用bool cmp(node a, node b)&#123; if(a.value1 != b.value1) return a.value1 &lt; b.value1; else return a.value2 &lt; b.value2;&#125; 代码：12345678910111213141516171819const int N=1005;int f[N],a,g[N]; int main() &#123; int pos1,pos2,cnt,len; len=cnt=0; while(cin&gt;&gt;a) &#123; pos1=upper_bound(f,f+len,a,greater&lt;int&gt;())-f; if(pos1==len) f[len++]=a; else f[pos1]=a; //为什么包含等于非严格递增或递减的时候我们反而要用upper呢，这是因为这样子才能做到只有更小的节点才能更新len的长度 pos2=lower_bound(g,g+cnt,a)-g; if(pos2==cnt) g[cnt++]=a; else g[pos2]=a; //这里是严格递增的，所以用lower_bound &#125; cout&lt;&lt;len&lt;&lt;endl; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 187.导弹防御系统链接分析这是一道df题目，虽然披着LIS的皮，对于每一个点，我们都有两种选择：放到上升子序列集合或者下降子序列集合之中 这个分析的太好了 注意事项： 可以使用while(!dfs(depth,0,0,0))depth++,这里的代码使用的是当dfs首次满足条件t==n（所有的点全部都集合之中）且集合数之和小于总数之和时对应的集合数之和的最小值，同样可以满足要求 必须要回溯，temp=h[i](d[i])...h[i](d[i])=temp否则会对之后的结果造成影响 代码123456789101112131415161718192021222324252627282930313233void dfs(int u, int d, int t) //u表示上升的系统个数，d表示下降的系统个数,t表示第t个数&#123; if(u + d &gt;= ans) return ; if(t == n)&#123; if(u + d &lt; ans)ans = u + d; return ; &#125; int i; for(i = 1; i &lt;= u; i++) //找到第一个末尾数小于a[t]的导弹系统 if(up[i] &lt; a[t])break; int temp = up[i]; up[i] = a[t];//添加到该导弹系统中 dfs(max(u, i), d, t + 1); up[i] = temp; //恢复现场 for(i = 1; i &lt;= d; i++)//找到第一个末尾数大于a[t]的导弹系统 if(down[i] &gt; a[t])break; temp = down[i]; down[i] = a[t];//添加到该导弹系统中去 dfs(u, max(d, i), t + 1); down[i] = temp;//恢复现场&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0)&#123; ans = 100; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; dfs(0, 0, 0); printf(\"%d\\n\", ans); &#125; return 0;&#125; 272.最大公共子序列链接https://www.acwing.com/problem/content/274/ 分析状态分析： 对于Ai,Bj,有 当Ai != Bj时，有f[i,j]==f[i-1,j]; 当Ai == Bj时，有F[i,j]=max(0&lt;=k&lt;j,Bk&lt;Bj){f[i-1,k]}+1 可以使用三重循环来得到解，但其实应该有优化，我们思考k，实际上每一次当第二层移动时，a[i]是不动的，对于b[j]，如果它小于当前a[i],那么他的上一层a[i-1] [j]就有可能变成a[i] [j]的父节点，我们用maxv将当前a[i] [j]对应的最大的a[i-1] [k]用一个数字存起来就行了 代码123456789for(int i=1;i&lt;=n;i++)&#123; int maxv=0; //初始化为1 for(int j=1;j&lt;=m;j++) if(a[i]==a[j]) f[i][j]=maxv+1; else f[i][j]=f[i][j]; if(a[i]&gt;a[j]) maxv=maxv(maxv,f[i-1][j]);&#125;","permalink":"http://yoursite.com/2020/04/20/acwing-%E8%AE%B0%E5%BD%95%20%E7%AC%AC%E4%B8%80%E7%AB%A0/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"基本数据结构 KMP模式匹配","date":"2020/04/17","text":"KMP匹配是判断两个线性表之间是否存在子母串关系的算法，并且能够定位到子串所处的位置 步骤1 .首先对小的字符串A进行自我”匹配”，设置next数组，其中next[i]表示“A中以a[i]结尾的非前缀子串”与”A的前缀”所能匹配到的最大长度 公式： next[i]=max{j},其中j&lt;i并且A[i-j+1 ~ i]==A[1 ~ j] 特别的：当不存在这样的 j 时，令next[i]=0 2 .对字符串A和B进行匹配，求出一个数组f，其中f[i]表示“B中以i结尾的字串”与”A的前缀”能够匹配到的最大长度 公式： f[i]=max{j},其中j&lt;i并且B[i-j+1 ~i]==A[1 ~ j] 当j的长度超过了n时，应该把j=next[j]; 引理对于j&lt;i,则j是next[i]的一个候选项，则小于j的next[i]的最大候选项是next[j],这是一个套娃的关系，直到满足条件或者next[j]==0 代码12345678910111213141516//next数组的求法next[1]=0;for(int i=2,j=0;i&lt;=n;i++)&#123; while(j&gt;0&amp;&amp;a[i]!=a[j+1]) j=next[j]; //找到符合条件的j,或者j==0; if(a[i]==a[j+1]) j++; //如果符合条件，加上末尾的元素 next[i]=j;&#125;//f数组的求法（大同小异）for(int i=1,j=0;i&lt;=m;i++)&#123; while(j&gt;0&amp;&amp;(j==n||b[i]!=a[j+1])) j=next[j]; if(b[i]==a[j+1]) j++; f[i]=j; //当f[i]==n的时候，说明子串就出现了&#125; 例题链接：POJ1961 题意：求循环元，首先我们设s[1~i]拥有长度为len的循环元 那么len必定满足以下条件： len|i &amp;&amp; s[len+1i]==s[1i-len] 而最小循环节则满足 s[len] (最小循环节)=next[i] 综上，得到代码 1234567891011121314151617181920void calc_next()&#123; next[1]=0; for(int i=2;j=0;i&lt;=n;i++)&#123; while(j&gt;0&amp;&amp;a[j+1]!=a[i]) j=next[j]; if(a[j+1]==a[i]) j++; next[i]=j; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; scanf(\"%s\",a+1); calc_next(); cout&lt;&lt;\"Test case\"&lt;&lt;++T&lt;&lt;endl; for(int i=2;i&lt;=n;i++)&#123; if(i%(i-next[i])==0&amp;&amp;i/(i-next[i])&gt;1)&#123; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;i/(i-next[i])&lt;&lt;endl; &#125; &#125; &#125;&#125;","permalink":"http://yoursite.com/2020/04/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 633 div.2&& round 634 div.3回顾","date":"2020/04/15","text":"codeforces上的比赛一直都很多，索性一次性将有价值的题目全部都放到一起来写了 round 633D题题意：给定指定的n个点，n-1条无向路（也就是说没有成环的可能），可以给路径随机分配正权值，从一个叶节点走到另外的叶节点路途中，所途径权值异或之和应该为零，问权值数量最少为多少，最多为多少 分析：首先我们先判断最小值的情况，我们可以发现，如果存在有两个节点之间的边数为奇数，那么权值的种类最小数必定为三，然后再去判断最大值的情况，两个或者两个以上叶节点同时连在了一个点上的情况中，这几个叶结点的权值边应该全部相同，所以只需要保留一个就可以了，把删掉的节点数用一个数字存起来，最大值就是 n-1-该数字 123456789101112131415161718192021222324252627282930313233343536373839404142const int N=1e5+7;int t,n,m,ans=0,fl=0;vector&lt;int&gt; v[100005],one;int qi=0;void dfs(int x,int y,int z)&#123; int aa=0; if(ans) return ; if(y!=-1&amp;&amp;v[x].size()==1)&#123; //从所有的叶节点出发，到其他的的叶节点，判断路径的奇偶 if(z%2) ans=1; return ; &#125; rep(i,0,v[x].size()-1)&#123; if(v[x][i]==y) continue; dfs(v[x][i],x,z+1); &#125; return ;&#125; int main()&#123; scanf(\"%d\",&amp;n); int minn=0,maxn=n-1; rep(i,1,n-1)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); v[a].push_back(b); v[b].push_back(a); &#125; rep(i,1,n)&#123; if(v[i].size()==1&amp;&amp;qi==0)&#123; qi=i; &#125; int cnt=0; rep(j,0,v[i].size()-1)&#123; //删除多余叶节点 if(v[v[i][j]].size()==1) cnt++; &#125; if(cnt&gt;=2) fl+=cnt-1; &#125; dfs(qi,-1,0); if(ans==0) minn=1; else minn=3; maxn-=fl; printf(\"%d %d\\n\",minn,maxn); round 634E1题题意：给定一个数组，问在不改变顺序的情况下，通过删减数组中元素，使得数组变成’ABA’型回文串是否可能，如果可能，请输出最大的回文串的长度 分析：dp题，用数组从左往右遍历，用a[i] [j]表示当前位置 j 情况下字符 i 的数量，然后再用从每一个位置开始， 以当前位置为左端，设置右端，再遍历26个字母的存在，使得 maxin=max(maxin,a[i] [r+1]-a[i] [l]); maxout=max(maxout,min(a[i] [l],a[i] [n]-a[i] [r+1])*2); 12345678910111213141516171819202122232425262728293031#define sz(a) int((a).size())#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)#define fore(i, l, r) for (int i = int(l); i &lt; int(r); ++i)int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;it : a) cin &gt;&gt; it; vector&lt;vector&lt;int&gt;&gt; cnt(26, vector&lt;int&gt;(n + 1)); forn(i, n) &#123; forn(j, 26) cnt[j][i + 1] = cnt[j][i]; ++cnt[a[i] - 1][i + 1]; &#125; int ans = 0; forn(i, 26) ans = max(ans, cnt[i][n - 1]); forn(l, n) fore(r, l, n) &#123; int cntin = 0, cntout = 0; forn(el, 26) &#123; cntin = max(cntin, cnt[el][r + 1] - cnt[el][l]); cntout = max(cntout, min(cnt[el][l], cnt[el][n] - cnt[el][r + 1]) * 2); &#125; ans = max(ans, cntin + cntout); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","permalink":"http://yoursite.com/2020/04/15/codeforces-round-633-div-2-round-634-div-3%20round%20635%20div.2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}],"title":"同余","date":"2020/04/13","text":"最近一次的周赛中暴露了同余逆元的短板，连板子都不会用，哎，只能加紧补了 定义如果a,b对正整数n的余数相等，那么a≡b(mod n) 同余类和剩余类对于所有a∈ [0,m-1], 集合 {a+km}对于m同余，该集合称为一个m的同类余，一个模m的同类余一共有{0,1,…..m-1}共m个，被称为完全剩余系 完全剩余系中与m互质的同类余有φ(m)个，被称为m的简化剩余系，简化剩余系的积也是m的简化剩余系 费马小定理若p是质数，则对于任意正整数a，有a^p≡a(mod p) 欧拉定理若正整数 a,n互质，那么a^φ(n)≡1(mod n),其中φ(n)是欧拉函数(不超过n的简化剩余系元素) 推论： 若正整数a ,n互质,对于任意正整数b， 有: a^b≡a^(b mod φ(n)) (mod n) 这些定理的证明链接：https://www.cnblogs.com/zylAK/p/9569668.html 快速幂取余的板子： 1234567891011LL mod(LL a,LL b,LL mod)&#123; LL ans=1; a%=mod; while(b)&#123; if(b&amp;1) //b==1 ans=ans*a%mod； a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125; 特别情况：当a，n不一定互质的且b&gt;φ(n)情况下，可以有： a^b≡a^(b modφ(n)+φ(n)) (mod n) 例题：POJ3696 最近发现欧拉定理的拓展不能用在快速幂板子，会导致答案错误，是一把双刃剑 拓展欧几里得算法某打不出名字的定理： 对于任意整数a,b,存在一对整数x,y,满足 ax+by == gcd(a,b) 代码实现 123456int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1,y=0; return a;&#125; int d=exgcd(b,a%b,x,y); int z=x; x=y; y=z-y*(a/b); return d;&#125; 乘法逆元若整数 b,m互质，并且 b|a，则存在一个整数x，使得a/b≡a*x(mod m),则x称为b的模m乘法逆元，记为b ^-1(mod m) 当模数m为质数时，b^m-2即为b的乘法逆元","permalink":"http://yoursite.com/2020/04/13/%E5%90%8C%E4%BD%99/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"单调栈问题：寻找最大矩形面积","date":"2020/04/12","text":"单调堆和队列可以对分析进行优化 单调堆：链接：POJ2559 1234567891011121314a[n+1]=p=0;for(int i=1;i&lt;=n+1;i++)&#123; if(a[i]&gt;s[p]) s[++p]=a[i],w[p]=1; else&#123; int width=0; while(s[p]&gt;a[i])&#123; width+=w[p]; ans=max(ans,(long long)width*s[p]); p--; &#125; s[++p]=a[i],w[p]=width+1; &#125;&#125; 单调队列问题最大子序和：给定一个长为N的整数序列，求找到一段不超过M的连续子序列，使得子序列中的所有数的和为最大值。N,M&lt;+3*10^5 分析我们思考一下，对于任意一个点i,以它结尾的子序列的的首位j一定存在如下情况：在不超过i的前置位M的情况下，s[j]一定是最小的，直到i右移，有新的单元s[i]加入能够替换s[j]或者超过最大限度M不得不换更右边的数字. 这里我们得用到单调递减序列，最优选择的序列集合一定是“下标位置递增，对应的前缀和的值也递增的”序列。我们这里使用一个一队列来保存这个序列。 操作如下： 判断队头决策与i的距离是否超出M的范围，若超出则出队 此时对头就是右端点为i时，左端点的最优选择 不断删除队尾决策，直到队尾对应的S值小于等于s[i] 。然后把i作为一个新决策入队 123456789int l=1,r=1;q[1]=0; //初始化在首位for(int i=1;i&lt;=n;i++)&#123; while(l&lt;=r&amp;&amp;q[l]&lt;i-m) l++; ans=max(ans,sum[i]-sum[q[l]]); while(l&lt;=r&amp;&amp;sum[q[r]]&gt;=sum[i]) r--; //如果s[i]最小，相当于清空了队列。。 q[++r]=i;&#125;","permalink":"http://yoursite.com/2020/04/12/%E5%8D%95%E8%B0%83%E5%A0%86%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces edu round 85 A-D","date":"2020/04/11","text":"昨晚的比赛并没有参加，但是今天早上参考大佬的代码，花时间把前面相对简单的四题给补了 链接https://codeforces.com/contest/1334 A题意思是进行一场游戏，会显示游戏次数和成功次数，由题意可知，游戏次数必定大于成功次数，然后问显示的数据是真是假，用几个条件判断一下就好了 123456789101112131415161718192021int main()&#123; cin&gt;&gt;n; while(n--)&#123; int flag=1,m1=0,m2=0; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; &#125; for(int i=1;i&lt;=m;i++)&#123; if(m1&gt;a[i]||m2&gt;b[i]||a[i]&lt;b[i]||b[i]-m2&gt;a[i]-m1)&#123; flag=0; break; &#125; m1=a[i],m2=b[i]; &#125; if(flag) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;&#125; B题题意：从一个序列里面随机抽取几个元素，使得这几个元素元素的平均数大于或等于目标值，问最多能抽取几个元素 首先排序(最大的在前面)，然后sum从左往右遍历，求和，如果一直满足条件ans++; 12345678910111213141516171819const int N=101000;int n,x,a[N],_;int main() &#123; for (scanf(\"%d\",&amp;_);_;_--) &#123; //这里使用scanf()函数对_进行赋值，然后直接_--，太骚了 scanf(\"%d%d\",&amp;n,&amp;x); rep(i,0,n) scanf(\"%d\",a+i); sort(a,a+n); reverse(a,a+n); //大佬的代码简洁，不写cmd，直接reverse满足 int ans=0; ll s=0; rep(i,0,n) &#123; s+=a[i]; if (s&gt;=(ll)(i+1)*x) ans=i+1; &#125; printf(\"%d\\n\",ans); &#125;&#125; C题题意：有一群怪物将作者围在中间，每个怪物分别拥有生命值和爆炸值两个数值，怪物死亡时会爆炸，对下一个怪物造成自己爆炸值数值的伤害(如果是最后一个，那么就是第一个，因为围成了圈)，求最低造成多少伤害，就能够将所有的怪物清除。 分析：对下一个怪物的伤害不会超过下一个怪物的生命值，所以杀死一个怪物的代价应该是 penalty=min(0,a[i]-b[i+n-1%n]) (前面的一个怪物已经被引爆的情况) 原本我是想用优先队列来写的，计算一个怪物的生命值和爆炸最多能对下一个怪物造成的伤害之和为序不停从堆中抽取，后来发现实际上怪物的生命值是动态的，不能用静态的生命值来算，只能作罢。看了别人的代码，才恍然大悟，这是一道贪心题，但是计算的应该是消灭一个怪物所要付出的代价而不是所能造成的最大化伤害。 123456789101112131415161718int _,n;ll extra[N],a[N],b[N];int main() &#123; for (scanf(\"%d\",&amp;_);_;_--) &#123; scanf(\"%d\",&amp;n); rep(i,0,n) scanf(\"%lld%lld\",a+i,b+i); ll s=0,d=1ll&lt;&lt;60;; rep(i,0,n) &#123; extra[i]=max(0ll,a[i]-b[(i+n-1)%n]); //这里计算在总生命值量和总爆炸伤害量已知的情况下，杀死一个怪物的代价 s+=extra[i]; // printf(\"%d %lld\\n\",i,extra[i]); &#125; rep(i,0,n) d=min(d,s-extra[i]+a[i]);//找到杀死一头怪物所要付出的最小代价 printf(\"%lld\\n\",d); &#125;&#125; 反思：刚开始我想岔是因为没有考虑到整体，而是盲目的从局部性价比最优的方式来计算，实际上从整体生命值和总体爆炸伤害值来看，如果我们选择不同的突破口，那么有一部分代价是完全逃避不了的，因为你如果不动它，那么上一个怪物的伤害值是无论如何都不可能杀死他的，我们只能做到第一步就找到代价最小的方式来减少损失 D题题意：有n个点，从1到 n ,再从 n 到1，任意两点之间都存在两条有向边，要求找到从1到n再回到n,经过且不重复经过每一条边，最小的字典序方案，给出字典序方案中从 l 位到 r 位的序列号 这道题为贪心和图论的结合，想到解决方法并不难，但是想要用代码实现感觉让人头大,感觉没有特定的板子啊，这是我看到的解法 123456789101112131415161718 int calc(ll x) &#123; if (x&gt;s[n-1]) return 1; auto a=lower_bound(s+1,s+n,x)-s; int b=x-s[a-1]; if (b%2==1) return a; else return b/2+a;&#125; int main() &#123; for (scanf(\"%d\",&amp;_);_;_--) &#123; scanf(\"%d%lld%lld\",&amp;n,&amp;l,&amp;r); rep(i,1,n+1) s[i]=s[i-1]+2*(n-i); for (ll i=l;i&lt;=r;i++) printf(\"%d \",calc(i)); puts(\"\");//换行 &#125;&#125;","permalink":"http://yoursite.com/2020/04/11/codeforces-edu-round-85-A-D/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"如何储存路径元素","date":"2020/04/10","text":"图的路径追溯一直都是个比较麻烦的问题，这里写一下看到的储存方法 最短路路径题目链接：POJ1734 无向图无向图使用floyd，最小环长度应该是： min( 1&lt;= i&lt; j &lt; k) {d[i,j] + a[i,k] + a[k,j]} 1234567891011121314151617181920212223242526272829303132333435363738394041const int N=310;int a[N][N],d[N][N],pos[N][N];int n,m,ans=0x3f3f3f3f;vector&lt;int&gt; path;void get_path(int x,int y)&#123; if(!pos[x][y]) return; get_path(x,pos[x][y]); path,push_back(pos[x][y]); get_path(pos[x][y],y);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(a,0x3f,sizeof a); for(int i=1;i&lt;=n;i++) a[i][i]=0; for(int i=1;i&lt;=m;i++)&#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; a[y][x]=a[x][y]=min(a[x][y],z); &#125; memcpy(d,a,sizeof a); //这波很骚； for(int k=1;ik&lt;=n;k++)&#123; for(int i=1;i&lt;ki++) for(int j=i+1;j&lt;k;j++) if(d[i][j]+a[i][k]+a[k][j]&lt;ans)&#123; ans=d[i][j]+a[i][k]+a[k][j]; path.clear(); path.push_back(i); get_path(i,j); path.push_back(j); path.push_back(k); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(d[i][j]&gt;d[i][k]+d[k][j])&#123; d[i][j]=d[i][k]+d[k][j]; pos[i][j]=k; &#125; &#125; ....&#125; 上面的代码使用了pos[i] [j]这个矩阵存储了两个点之间的中间路径，同时get_back函数通过递归调用再次得出i与k,k与j之间的关系，但是注意，这个方法只能存储最短路的路径，不能存储所有的路径。。。 有向图有向图使用二分堆优化的dijkstra,同样是使用pos存储中间节点，方法：枚举1-n之间的起点s,从s开始出堆，但是s出堆之后立刻将d[s]设置为无穷大，这样子s第二次入堆时得到的就是最小有向环","permalink":"http://yoursite.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）bellman-ford和SPFA","date":"2020/04/10","text":"bellman-ford流程： 扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y] 重复以上步骤，直到没有更新步骤发生 复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra SPFA: 建立一个队列，最初队列中只有起点1 取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队 重复上面步骤，直到队列为空 这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用 1234567891011121314151617181920queue(int) q;void SPFA()&#123; d[1]=0,v[1]=1; q.push(1); while(q.size())&#123; int x=q.front(); q.pop(); v[x]=0; for(int i=head[x];i;i=next[i])&#123; int y=ver[i],x=edge[i]; if(d[y]&gt;d[x]+z)&#123; d[y]=d[x]+z; if(!v[x]) q.push(y),v[y]=1; &#125; &#125; &#125;&#125;int main()&#123; ... SPFA();&#125; 但是该方法对于边权存在为负数的边同样适用。 并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）邻接矩阵和邻接表","date":"2020/04/10","text":"对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。 邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。 邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。 插入和遍历代码： 1234567891011//插入有向边(x,y,z)void add(int x,int y,int z)&#123; ver[++tot]=y,edge[tot]=z; next[tot]=head[x],head[x]=tot; //注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的&#125;//遍历所有x出发的有向边for(int i=head[x];i;i=next[i])&#123; //这里面的i如果为0.结束循环 int y=ver[i],x=ver[i];&#125;","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 632 Div.2回顾","date":"2020/04/09","text":"这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ 比赛链接 https://codeforces.com/contest/1333 A题一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1. 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int t; cin&gt;&gt;t; int m,n; while(t--)&#123; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++)&#123; if(i==1&amp;&amp;j==1)&#123; cout&lt;&lt;'W'; &#125; else&#123; cout&lt;&lt;'B'; &#125; &#125; cout&lt;&lt;endl; &#125;&#125; return 0;&#125; B题给定上下两个序列，上面一个序列可以进行一种运算: 对任意i &lt; j ,可以使得aj = ai+aj 要求是能否通过这种运算使得上面的数列等于下面的，其实就是找上面数列的1和-1的位置，再和每一位进行比对。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define mod 1000000007#define mod9 998244353typedef unsigned long long ull;typedef long long ll;typedef double db;typedef long double ld;const db eps=1e-10;const int INF = 0x3f3f3f3f;const ll inf=0x3f3f3f3f3f3f3f3f;const int N=1e5+7;using namespace std;int t,n,m,k=0;int a[N]=&#123;0&#125;,b[N]=&#123;0&#125;;int main()&#123; while(~scanf(\"%d\",&amp;t))&#123; while(t--)&#123; int flag=0; int vis[3]=&#123;0&#125;; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;b[i]); if(b[i]&gt;a[i]&amp;&amp;vis[0]==0) flag=1; if(b[i]&lt;a[i]&amp;&amp;vis[1]==0) flag=1; if(a[i]==1) vis[0]=1; if(a[i]==-1) vis[1]=1; &#125; if(flag) cout&lt;&lt;\"NO\"&lt;&lt;endl; else cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; &#125; return 0;&#125; C题题意给定一个序列，只能从左端或者右端截取一段走形成新的子序列，不存在可以从中间直接拿取（我就理解错了），所以这样子算来实际的序列数量是1+2+…..n，即 (n+1)*n/2 ,只要子序列中任意一个存在和为零的情况，那么这个序列就不符合要求，结果求得是符合要求的序列的数量，刚开始我还以为是一个求子序列和的问题，没有特别多的思路就选择做了后面的题目，毕竟2^n难以处理，结果因为传达了错误的题意还坑了和自己的一起写的大佬（捂脸） 处理：由于其子序列取得方式，我们可以推理，假设一个序列和为零，那么其右端所有序列（即母序列）也不符合要求，进一步想，我们会发现，假设从左往右计数求和sum，如果sum的值出现了两次，那么说明中间一段必定为和为零的序列，所以可以使用map记录下每个sum出现的最新位置，如果出现了重复的sum,就对其右边的母序列进行清除。不用注意重复子序列。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;typedef long long ll;const ll mod=1e9+7;const ll N=2e5+5;const ll M=2e4+5;const double eps=1e-7;using namespace std;int a[N];map&lt;long,long&gt;mp;int main()&#123; ll ans=0,n,sum=0,cnt=-1; cin&gt;&gt;n; for(ll i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; mp[0]=1; //这里设置成1，避免首元素就是0的情况 for(ll i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(mp.count(sum))&#123; cnt=max(cnt,mp[sum]); &#125; ans+=i-cnt; mp[sum]=i+1; //这里设置成i+1,剪掉0子序列的首元素 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D题将序列当中全部向左转的跳到左边，右转的调到右边，这里看到了一位学长的代码，非常熟练地使用了各种STL，我从中学到了很多新的东西，比如范围for循环 12vector&lt;type&gt; k;for(auto n:k) cout&lt;&lt;n; 题解如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include&lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N = 2e5+5;typedef long long ll;char a[N];int main()&#123; int n,m,i,j,k,t=0; scanf(\"%d %d\",&amp;n,&amp;k); scanf(\"%s\",a+1); int sum = 0; vector&lt;vector&lt;int&gt; &gt;q; q.clear(); int ans = 0; while(1)&#123; bool flag = true; vector&lt;int&gt; p; p.clear(); for(i=1;i&lt;n;i++)&#123; if(a[i]=='R'&amp;&amp;a[i+1]=='L') p.push_back(i++),swap(a[i],a[i-1]), flag=false,sum++; &#125; if(flag) break; q.push_back(p); &#125; if(q.size()&gt;k||sum&lt;k)&#123; printf(\"-1\\n\"); return 0; &#125; for(vector&lt;int&gt; d:q)&#123; printf(\"%d\",d.size()); for(int j:d) printf(\" %d\",j); printf(\"\\n\"); &#125; return 0;&#125;","permalink":"http://yoursite.com/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）单源最短路径-dijkstra","date":"2020/04/06","text":"目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。 初始化d[1]=0,然后将其余的 distance 全部设置为最大 进行n-1次循环，每次都找最小了distance[x],将x标记 扫描该x的全部出边（x,y,z）,if d[y]&gt;d[x]+z),更新d[y] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int maxn=105;const int INF=0x3f3f3f3f;int d[maxn],a[maxn][maxn],v[maxn],ans,m;void search()&#123; memset(v,0,sizeof v); for(int i=1;i&lt;m;i++)&#123; int x=0; for(int j=1;j&lt;=m;j++)&#123; if(!v[j]&amp;&amp;(x==0||d[j]&lt;d[x])) x=j; &#125; v[x]=1; for(int j=1;j&lt;=m;j++)&#123; d[j]=min(d[j],d[x]+a[x][j]); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m; string s; for(int i=1;i&lt;=m;i++)&#123; a[i][i]=0; &#125; for(int i=2;i&lt;=m;i++)&#123; for(int j=1;j&lt;i;j++)&#123; cin&gt;&gt;s; if(s==\"x\")&#123; a[i][j]=a[j][i]=INF; &#125; else&#123; int n=0; for(int k=0;k&lt;s.size();k++)&#123; n=n*10+s[k]-'0'; &#125; a[i][j]=a[j][i]=n; &#125; &#125; &#125; for(int i=2;i&lt;=m;i++)&#123; d[i]=INF; &#125; d[1]=0; search(); ans=0; for(int i=1;i&lt;=m;i++)&#123; ans=max(d[i],ans); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 时间复杂度O(n^2)，主要复杂度来自第一步对全局最小值的寻找，适用于求单源路径. 下面是使用二叉树堆对dist进行维护之后，可以在O(mlogn)的时间内实现dijkstra: 12345678910111213141516171819202122232425262728293031323334353637383940const int N=10010,M=100010;int head[N],ver[M],edge[M],next[M],d[N];bool v[N];int n,m,tot;priority_queue&lt;pair&lt;int,int&gt;&gt; q;//注意这里的key值是dist值的相反数，因为要选取最小值，第二个值为对应的节点编号void add(int x,int y,int z)&#123; ver[++tot]=y,edge[tot]=z; next[tot]=head[x],head[x]=tot;&#125;void dijkstra()&#123; memset(v,0,sizeof(v)); memset(d,0,sizeof(d)); d[1]=0; q.push(make_pair(0,1)); while(q.size())&#123; int x=q.top().second,q.pop(); if(v[x]) continue; v[x]=1; for(int i=head[x],i;i=next[i])&#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z)&#123; d[y]=d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; add(x,y,z); &#125; dijkstra(); for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;d[i]&lt;&lt;endl; &#125;&#125;","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）两点间无向最短路径 floyd","date":"2020/04/06","text":"floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化 如果想要了解内部缘由不妨移步：为什么k要放在最外层 设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。 得到公式： D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]) 可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=305,INF=0x3f3f3f3f;int d[maxn][maxn];int a[maxn];int n,m;void init()&#123; for(int i=0;i&lt;maxn;i++) for(int j=0;j&lt;maxn;j++) if(i==j) d[i][j]=0; else d[i][j]=INF;&#125;void floyd(void)&#123; //floyd的状态转移方程：d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]),可以转换成三重循环的。。 for(int k=1;k&lt;=n;k++) //最外层循环是为了找到能不能有其他点帮助目标点完成最短路。。。 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; init(); while(m--) &#123; int k; cin&gt;&gt;k; for(int i=0;i&lt;k;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;k;i++) for(int j=i+1;j&lt;k;j++) d[a[i]][a[j]]=d[a[j]][a[i]]=1; &#125; floyd(); int ans=INF; for(int i=1;i&lt;=n;i++) &#123; int sum=0; for(int j=1;j&lt;=n;j++) sum+=d[i][j]; ans=min(ans,sum); &#125; cout&lt;&lt;ans*100/(n-1)&lt;&lt;endl; return 0;&#125; 传递闭包：传递推导尽量多的元素之间的关系(感觉并查集也能解决相等的关系，但是大于小于不行) 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]|=d[i][k]&amp;d[k][j];","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/","photos":[]},{"tags":[],"title":"（图论初学）单源最短路径：dijkstra","date":"2020/04/04","text":"目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。 初始化d[1]=0,然后将其余的dist全部设置为最大 进行n-1次循环，每次都找最小了dist[x],将x标记 扫描该x的全部出边（x,y,z）,ifd[y]&gt;d[x]+z),更新d[y] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int maxn=105;const int INF=0x3f3f3f3f;int d[maxn],a[maxn][maxn],v[maxn],ans,m;void search()&#123; memset(v,0,sizeof v); for(int i=1;i&lt;m;i++)&#123; int x=0; for(int j=1;j&lt;=m;j++)&#123; if(!v[j]&amp;&amp;(x==0||d[j]&lt;d[x])) x=j; &#125; v[x]=1; for(int j=1;j&lt;=m;j++)&#123; d[j]=min(d[j],d[x]+a[x][j]); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m; string s; for(int i=1;i&lt;=m;i++)&#123; a[i][i]=0; &#125; for(int i=2;i&lt;=m;i++)&#123; for(int j=1;j&lt;i;j++)&#123; cin&gt;&gt;s; if(s==\"x\")&#123; a[i][j]=a[j][i]=INF; &#125; else&#123; int n=0; for(int k=0;k&lt;s.size();k++)&#123; n=n*10+s[k]-'0'; &#125; a[i][j]=a[j][i]=n; &#125; &#125; &#125; for(int i=2;i&lt;=m;i++)&#123; d[i]=INF; &#125; d[1]=0; search(); ans=0; for(int i=1;i&lt;=m;i++)&#123; ans=max(d[i],ans); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 时间复杂度O(n^2)…适用于求单源路径…最优序列方法，之后更新… categrories: ACM","permalink":"http://yoursite.com/2020/04/04/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9Adijkstra/","photos":[]}],"categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"acwing","slug":"acwing","permalink":"http://yoursite.com/tags/acwing/"},{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}]}