{"meta":{"title":"Hexo","subtitle":"","description":"�ڻ����ı�Ե�������X�m","author":"softmountain","url":"http://yoursite.com","root":"/"},"posts":[{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"如何储存路径元素","date":"2020/04/10","text":"======最短路路径 题目链接：POJ1734 ###无向图### 无向图使用floyd，最小环长度应该是： min(1>m; memset(a,0x3f,sizeof a); for(int i=1;ix>>y>>z; a[y][x]=a[x][y]=min(a[x][y],z); } memcpy(d,a,sizeof a); //这波很骚； for(int k=1;ik","permalink":"http://yoursite.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）bellman-ford和SPFA","date":"2020/04/10","text":"bellman-ford流程： 扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y] 重复以上步骤，直到没有更新步骤发生 复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra SPFA: 建立一个队列，最初队列中只有起点1 取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队 重复上面步骤，直到队列为空 这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用 1234567891011121314151617181920queue(int) q;void SPFA()&#123; d[1]=0,v[1]=1; q.push(1); while(q.size())&#123; int x=q.front(); q.pop(); v[x]=0; for(int i=head[x];i;i=next[i])&#123; int y=ver[i],x=edge[i]; if(d[y]&gt;d[x]+z)&#123; d[y]=d[x]+z; if(!v[x]) q.push(y),v[y]=1; &#125; &#125; &#125;&#125;int main()&#123; ... SPFA();&#125; 但是该方法对于边权存在为负数的边同样适用。 并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）邻接矩阵和邻接表","date":"2020/04/10","text":"对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。 邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。 邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。 插入和遍历代码： 1234567891011//插入有向边(x,y,z)void add(int x,int y,int z){ ver[++tot]=y,edge[tot]=z; next[tot]=head[x],head[x]=tot; //注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的}//遍历所有x出发的有向边for(int i=head[x];i;i=next[i]){ //这里面的i如果为0.结束循环 int y=ver[i],x=ver[i];}","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 632 Div.2回顾","date":"2020/04/09","text":"这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ ======比赛链接 https://codeforces.com/contest/1333 ======A题 一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1. 12345678910111213141516171819202122232425#includeusing namespace std;typedef long long ll;int main(){ int t; cin>>t; int m,n; while(t--){ cin>>m>>n; for(int i=1;i","permalink":"http://yoursite.com/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）单源最短路径-dijkstra","date":"2020/04/06","text":"目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。 初始化d[1]=0,然后将其余的 distance 全部设置为最大 进行n-1次循环，每次都找最小了distance[x],将x标记 扫描该x的全部出边（x,y,z）,if d[y]>d[x]+z),更新d[y] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include#include#include#include#includeusing namespace std;const int maxn=105;const int INF=0x3f3f3f3f;int d[maxn],a[maxn][maxn],v[maxn],ans,m;void search(){ memset(v,0,sizeof v); for(int i=1;iz; add(x,y,z); } dijkstra(); for(int i=1;i","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）两点间无向最短路径 floyd","date":"2020/04/06","text":"floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化 如果想要了解内部缘由不妨移步：为什么k要放在最外层 设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。 得到公式： D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]) 可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include#include#includeusing namespace std;const int maxn=305,INF=0x3f3f3f3f;int d[maxn][maxn];int a[maxn];int n,m;void init(){ for(int i=0;i>k; for(int i=0;i>a[i]; } for(int i=0;i","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/","photos":[]}],"categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]}