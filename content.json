{"meta":{"title":"Hexo","subtitle":"","description":"�ڻ����ı�Ե�������X�m","author":"softmountain","url":"http://yoursite.com","root":"/"},"posts":[{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"基本数据结构 KMP模式匹配","date":"2020/04/17","text":"KMP匹配是判断两个线性表之间是否存在子母串关系的算法，并且能够定位到子串所处的位置 步骤1 .首先对小的字符串A进行自我”匹配”，设置next数组，其中next[i]表示“A中以a[i]结尾的非前缀子串”与”A的前缀”所能匹配到的最大长度 公式： next[i]=max{j},其中j>m){ scanf(\"%s\",a+1); calc_next(); cout","permalink":"http://yoursite.com/2020/04/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"CF每日一题 四月","date":"2020/04/17","text":"","permalink":"http://yoursite.com/2020/04/17/CF%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%9B%9B%E6%9C%88/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 633 div.2&& round 634 div.3回顾","date":"2020/04/15","text":"codeforces上的比赛一直都很多，索性一次性将有价值的题目全部都放到一起来写了 round 633D题题意：给定指定的n个点，n-1条无向路（也就是说没有成环的可能），可以给路径随机分配正权值，从一个叶节点走到另外的叶节点路途中，所途径权值异或之和应该为零，问权值数量最少为多少，最多为多少 分析：首先我们先判断最小值的情况，我们可以发现，如果存在有两个节点之间的边数为奇数，那么权值的种类最小数必定为三，然后再去判断最大值的情况，两个或者两个以上叶节点同时连在了一个点上的情况中，这几个叶结点的权值边应该全部相同，所以只需要保留一个就可以了，把删掉的节点数用一个数字存起来，最大值就是 n-1-该数字 123456789101112131415161718192021222324252627282930313233343536373839404142const int N=1e5+7;int t,n,m,ans=0,fl=0;vector v[100005],one;int qi=0;void dfs(int x,int y,int z){ int aa=0; if(ans) return ; if(y!=-1&&v[x].size()==1){ //从所有的叶节点出发，到其他的的叶节点，判断路径的奇偶 if(z%2) ans=1; return ; } rep(i,0,v[x].size()-1){ if(v[x][i]==y) continue; dfs(v[x][i],x,z+1); } return ;} int main(){ scanf(\"%d\",&n); int minn=0,maxn=n-1; rep(i,1,n-1){ int a,b; scanf(\"%d%d\",&a,&b); v[a].push_back(b); v[b].push_back(a); } rep(i,1,n){ if(v[i].size()==1&&qi==0){ qi=i; } int cnt=0; rep(j,0,v[i].size()-1){ //删除多余叶节点 if(v[v[i][j]].size()==1) cnt++; } if(cnt>=2) fl+=cnt-1; } dfs(qi,-1,0); if(ans==0) minn=1; else minn=3; maxn-=fl; printf(\"%d %d\\n\",minn,maxn); round 634E1题题意：给定一个数组，问在不改变顺序的情况下，通过删减数组中元素，使得数组变成’ABA’型回文串是否可能，如果可能，请输出最大的回文串的长度 分析：dp题，用数组从左往右遍历，用a[i] [j]表示当前位置 j 情况下字符 i 的数量，然后再用从每一个位置开始， 以当前位置为左端，设置右端，再遍历26个字母的存在，使得 maxin=max(maxin,a[i] [r+1]-a[i] [l]); maxout=max(maxout,min(a[i] [l],a[i] [n]-a[i] [r+1])*2); 12345678910111213141516171819202122232425262728293031#define sz(a) int((a).size())#define forn(i, n) for (int i = 0; i < int(n); ++i)#define fore(i, l, r) for (int i = int(l); i < int(r); ++i)int main() { int t; cin >> t; while (t--) { int n; cin >> n; vector a(n); for (auto &it : a) cin >> it; vector cnt(26, vector(n + 1)); forn(i, n) { forn(j, 26) cnt[j][i + 1] = cnt[j][i]; ++cnt[a[i] - 1][i + 1]; } int ans = 0; forn(i, 26) ans = max(ans, cnt[i][n - 1]); forn(l, n) fore(r, l, n) { int cntin = 0, cntout = 0; forn(el, 26) { cntin = max(cntin, cnt[el][r + 1] - cnt[el][l]); cntout = max(cntout, min(cnt[el][l], cnt[el][n] - cnt[el][r + 1]) * 2); } ans = max(ans, cntin + cntout); } cout < ans <","permalink":"http://yoursite.com/2020/04/15/codeforces-round-633-div-2-round-634-div-3%20round%20635%20div.2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"}],"title":"同余","date":"2020/04/13","text":"最近一次的周赛中暴露了同余逆元的短板，连板子都不会用，哎，只能加紧补了 定义如果a,b对正整数n的余数相等，那么a≡b(mod n) 同余类和剩余类对于所有a∈ [0,m-1], 集合 {a+km}对于m同余，该集合称为一个m的同类余，一个模m的同类余一共有{0,1,…..m-1}共m个，被称为完全剩余系 完全剩余系中与m互质的同类余有φ(m)个，被称为m的简化剩余系，简化剩余系的积也是m的简化剩余系 费马小定理若p是质数，则对于任意正整数a，有a^p≡a(mod p) 欧拉定理若正整数 a,n互质，那么a^φ(n)≡1(mod n),其中φ(n)是欧拉函数(不超过n的简化剩余系元素) 推论： 若正整数a ,n互质,对于任意正整数b， 有: a^b≡a^(b mod φ(n)) (mod n) 这些定理的证明链接：https://www.cnblogs.com/zylAK/p/9569668.html 快速幂取余的板子： 1234567891011LL mod(LL a,LL b,LL mod){ LL ans=1; a%=mod; while(b){ if(b&1) //b==1 ans=ans*a%mod； a=a*a%mod; b>>=1; } return ans;} 特别情况：当a，n不一定互质的且b>φ(n)情况下，可以有： a^b≡a^(b modφ(n)+φ(n)) (mod n) 例题：POJ3696 最近发现欧拉定理的拓展不能用在快速幂板子，会导致答案错误，是一把双刃剑 拓展欧几里得算法某打不出名字的定理： 对于任意整数a,b,存在一对整数x,y,满足 ax+by == gcd(a,b) 代码实现 123456int exgcd(int a,int b,int &x,int &y){ if(b==0) { x=1,y=0; return a;} int d=exgcd(b,a%b,x,y); int z=x; x=y; y=z-y*(a/b); return d;} 乘法逆元若整数 b,m互质，并且 b|a，则存在一个整数x，使得a/b≡a*x(mod m),则x称为b的模m乘法逆元，记为b ^-1(mod m) 当模数m为质数时，b^m-2即为b的乘法逆元","permalink":"http://yoursite.com/2020/04/13/%E5%90%8C%E4%BD%99/","photos":[]},{"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"title":"单调栈问题：寻找最大矩形面积","date":"2020/04/12","text":"题意：求若干个相邻矩形并集内部所能找到的最大矩形面积 链接：POJ2559 1234567891011121314a[n+1]=p=0;for(int i=1;is[p]) s[++p]=a[i],w[p]=1; else{ int width=0; while(s[p]>a[i]){ width+=w[p]; ans=max(ans,(long long)width*s[p]); p--; } s[++p]=a[i],w[p]=width+1; }}","permalink":"http://yoursite.com/2020/04/12/%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces edu round 85 A-D","date":"2020/04/11","text":"昨晚的比赛并没有参加，但是今天早上参考大佬的代码，花时间把前面相对简单的四题给补了 链接https://codeforces.com/contest/1334 A题意思是进行一场游戏，会显示游戏次数和成功次数，由题意可知，游戏次数必定大于成功次数，然后问显示的数据是真是假，用几个条件判断一下就好了 123456789101112131415161718192021int main(){ cin>>n; while(n--){ int flag=1,m1=0,m2=0; cin>>m; for(int i=1;i>a[i]>>b[i]; } for(int i=1;ia[i]||m2>b[i]||a[i]a[i]-m1){ flag=0; break; } m1=a[i],m2=b[i]; } if(flag) cout","permalink":"http://yoursite.com/2020/04/11/codeforces-edu-round-85-A-D/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"如何储存路径元素","date":"2020/04/10","text":"最短路路径题目链接：POJ1734 无向图无向图使用floyd，最小环长度应该是： min( 1>m; memset(a,0x3f,sizeof a); for(int i=1;ix>>y>>z; a[y][x]=a[x][y]=min(a[x][y],z); } memcpy(d,a,sizeof a); //这波很骚； for(int k=1;ik","permalink":"http://yoursite.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E8%B7%AF%E5%BE%84%E5%85%83%E7%B4%A0/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）bellman-ford和SPFA","date":"2020/04/10","text":"bellman-ford流程： 扫描所有的边(x,y,z),如果dist[y]&gt; dist[x]+z,更新dist[y] 重复以上步骤，直到没有更新步骤发生 复杂度O(nm),特别复杂，甚至不如使用邻接矩阵的dijkstra SPFA: 建立一个队列，最初队列中只有起点1 取出队头节点下x,扫描x的所有出边(x,y,z),如果dist[y]&gt;dist[x]+z，则更新dist[y],同时如果y不在队中，那么使y入队 重复上面步骤，直到队列为空 这个方法的最终目的就是通过便利使得所有的dist[y]&lt;=dist[x]+z成立。复杂度取决于给出的图，如果类似于矩阵，那么结果还是会变成O(nm),谨慎使用 1234567891011121314151617181920queue(int) q;void SPFA()&#123; d[1]=0,v[1]=1; q.push(1); while(q.size())&#123; int x=q.front(); q.pop(); v[x]=0; for(int i=head[x];i;i=next[i])&#123; int y=ver[i],x=edge[i]; if(d[y]&gt;d[x]+z)&#123; d[y]=d[x]+z; if(!v[x]) q.push(y),v[y]=1; &#125; &#125; &#125;&#125;int main()&#123; ... SPFA();&#125; 但是该方法对于边权存在为负数的边同样适用。 并且，如果不存在边权为负数的边，那么同样可以使用priority_queue对其进行优化，同样可以得到O(mlogn)的时间复杂度","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89bellman-ford%E5%92%8CSPFA/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）邻接矩阵和邻接表","date":"2020/04/10","text":"对于有向图和无向图（当作有向图来处理），都有两周储存的方式，分别是邻接矩阵或邻接表。 邻接矩阵：就是二位数组，对于任意a [i] [j],如果i==j,那么a ij的值为零，如果a[i] [j]存在，那么值为w[i] [j],如果不存在，那么值为无穷大。空间复杂度n^2。 邻接链表：含有四个数组，分别为长度为n(头节点数量)的head,长度为m(所有路径数量)ver（记录终边），edge（记录边权），next（记录下一条边的位置）。空间复杂度n+m。 插入和遍历代码： 1234567891011//插入有向边(x,y,z)void add(int x,int y,int z){ ver[++tot]=y,edge[tot]=z; next[tot]=head[x],head[x]=tot; //注意这一步，由于是将前面的head[x]给了后面的next[tot],所以遍历的时候是从后面到前面的}//遍历所有x出发的有向边for(int i=head[x];i;i=next[i]){ //这里面的i如果为0.结束循环 int y=ver[i],x=ver[i];}","permalink":"http://yoursite.com/2020/04/10/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8/","photos":[]},{"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}],"title":"codeforces round 632 Div.2回顾","date":"2020/04/09","text":"这次的参加人数特别多，大概是新冠肺炎影响居家人数增多吧。题目按照LPT和KEVIN大佬的说法，特别水，但是我还是和之前差不多的结果，看来我的水分拧都拧不干了。。。大哭QAQ 比赛链接 https://codeforces.com/contest/1333 A题一如既往，不是很难，拼的是手速和灵光，题面看起来很复杂，意思是两种方块在给定的方形大小内镶嵌，如果一块方块四个方向中存在有另一种方块，那么可以使得所属种类数加一，对另一种方块亦然，要求是B类方块是W类方块数+1，这样的话只需在左上角放一块W，其余全部放B即可，这样数量刚好为2=1+1. 12345678910111213141516171819202122232425#includeusing namespace std;typedef long long ll;int main(){ int t; cin>>t; int m,n; while(t--){ cin>>m>>n; for(int i=1;i","permalink":"http://yoursite.com/2020/04/09/codeforces-round-632-Div-2%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）单源最短路径-dijkstra","date":"2020/04/06","text":"目标：寻找起始点到目标点的最短路径，做法，每次扫描最短出边，加入路径。。。 初始化d[1]=0,然后将其余的 distance 全部设置为最大 进行n-1次循环，每次都找最小了distance[x],将x标记 扫描该x的全部出边（x,y,z）,if d[y]>d[x]+z),更新d[y] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include#include#include#include#includeusing namespace std;const int maxn=105;const int INF=0x3f3f3f3f;int d[maxn],a[maxn][maxn],v[maxn],ans,m;void search(){ memset(v,0,sizeof v); for(int i=1;iz; add(x,y,z); } dijkstra(); for(int i=1;i","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra/","photos":[]},{"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}],"title":"（图论初学）两点间无向最短路径 floyd","date":"2020/04/06","text":"floyd主要是使用了dp的思想，最主要的疑惑恐怕是i，j，k三个变量的位置为何不可变化 如果想要了解内部缘由不妨移步：为什么k要放在最外层 设D[k,i,j]表示经过若干个编号不超过k的结点从i到j的最短路径长度,可划分为子问题，经过编号不超过k-1从i到j,或者先从i到k,再到j。 得到公式： D[k,i,j,]=min(D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]) 可以转化为：D[i,j]=min(D[i,j],D[i,k]+D[k,j]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include#include#includeusing namespace std;const int maxn=305,INF=0x3f3f3f3f;int d[maxn][maxn];int a[maxn];int n,m;void init(){ for(int i=0;i>k; for(int i=0;i>a[i]; } for(int i=0;i","permalink":"http://yoursite.com/2020/04/06/%EF%BC%88%E5%9B%BE%E8%AE%BA%E5%88%9D%E5%AD%A6%EF%BC%89%E5%8D%95%E6%BA%90%E6%97%A0%E5%90%91%E8%B7%AF%E5%BE%84-floyed/","photos":[]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]}